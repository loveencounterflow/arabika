// Generated by CoffeeScript 1.7.1
(function() {
  var TRM, alert, badge, check_nws, debug, echo, glob, help, info, log, njs_fs, rainbow, rpr, try_escodegen, try_escodegen_1, try_esprima, try_esquery, try_esquery_1, try_splice, warn, whisper, π,
    __slice = [].slice;

  njs_fs = require('fs');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '﴾0-experiments﴿';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  rainbow = TRM.rainbow.bind(TRM);


  /* https://github.com/isaacs/node-glob */

  glob = require('glob');


  /* https://github.com/loveencounterflow/coffeenode-packrattle,
  forked from https://github.com/robey/packrattle
   */

  π = require('coffeenode-packrattle');

  this._ = function() {
    var f, name, rv;
    for (name in A) {
      info(name);
    }

    /* TAINT translation routines should be
    (1) independent from grammar, so we can translate to different targets;
    (2) be modular and extensible, so new forms of expression can implement both new syntax
        and ways of translation to different targets.
    Point (2) is not possible with a `switch`-dispatcher.
     */
    this.as_coffeescript = function(node) {

      /* TAINT makeshift for smooth transition to SpiderMonkey Parser API */
      var content, crumb, crumbs_node, expression_node, identifier_node, left, operator, right, sub_expression, sub_type, type;
      if ((type = node['type']) != null) {
        null;
      } else {
        type = node[0], content = 2 <= node.length ? __slice.call(node, 1) : [];
      }
      switch (type) {
        case 'assignment':
          if (content.length !== 2) {
            throw new Error("expected identifier and expression node, got " + (rpr(content)));
          }
          identifier_node = content[0], expression_node = content[1];
          if ((sub_type = identifier_node[0]) !== 'identifier') {
            throw new Error("expected identifier node, got " + sub_type);
          }
          crumbs_node = ['crumbs', identifier_node[1]];
          return "$v" + (this.as_coffeescript(crumbs_node)) + " = " + (this.as_coffeescript(expression_node));
        case 'crumbs':

          /* TAINT must escape identifier */

          /* TAINT shouldn't we also use variables in the target language? */
          return ((function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = content.length; _i < _len; _i++) {
              crumb = content[_i];
              _results.push("[ '" + crumb + "' ]");
            }
            return _results;
          })()).join('');
        case 'expression':

          /* TAINT how to join? */
          return ((function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = content.length; _i < _len; _i++) {
              sub_expression = content[_i];
              _results.push(this.as_coffeescript(sub_expression));
            }
            return _results;
          }).call(this)).join(' ');
        case 'Literal':

          /* TAINT better to use node[ 'raw' ]? */
          return rpr(node['value']);
        case 'BinaryExpression':

          /* TAINT wrongly assumes operator has direct equivalent in target language */
          left = node.left, operator = node.operator, right = node.right;
          return "" + (this.as_coffeescript(left)) + " " + operator + " " + (this.as_coffeescript(right));
        case 'text':

          /* TAINT text literal should be kept intact */
          return rpr(content[1]);
        case 'symbol':
          return this.as_coffeescript(['text', '"', content[0], '"']);
        case 'use':

          /* TAINT `use` statement not to be translated */
          return "### `use` statement ###\nuse " + (this.as_coffeescript(content[0]));
        default:
          warn("skipped " + type + " " + (rpr(content)));
          return "???";
      }
    };
    f = function() {
      var node;
      node = A.UNSORTED.assignment.run('xy: 20 + 3');
      info(this.as_coffeescript(node));
      node = A.UNSORTED.assignment.run('foo/bar: 20 + 3');
      info(this.as_coffeescript(node));
      info('\n' + rpr(A.UNSORTED.list.run('[ 3, 10, 200 ]')));
      info('\n' + rpr(A.UNSORTED.list.run('[]')));
      info('\n' + rpr(A.UNSORTED.assignment.run('xy: 20 + 3')));
      info('\n' + rpr(A.UNSORTED.expression.run('3 + 10 + 200')));
      info('\n' + rpr(A.UNSORTED.expression.run('3 * 10 + 200')));
      info('\n' + rpr(A.UNSORTED.expression.run('3 + 10 * 200')));
      info('\n' + rpr(A.UNSORTED.expression.run('42')));
      info(rpr(A.TEXT._single_quote.run("'")));
      info(rpr(A.TEXT._double_quote.run('"')));
      info(rpr(A.TEXT._chr_escaper.run('\\')));
      info(rpr(A.TEXT.simple_escape.run('n')));
      info(rpr(A.TEXT._unicode_hex.run('u4e01')));
      info(rpr(A.TEXT._escaped.run('\\u4e01')));
      info(rpr(A.TEXT._escaped.run('\\n')));
      info(rpr(A.TEXT._nosq.run('abcdef')));
      info(rpr(A.TEXT._nodq.run('ioxuy')));
      info(rpr(A.TEXT._dq_text_literal.run('"foo"')));
      info(rpr(A.TEXT._sq_text_literal.run("'foo'")));
      info(rpr(node = A.TEXT.literal.run('"helo"')));
      debug('\n' + this.as_coffeescript(node));
      info(rpr(node = A.TEXT.literal.run("'helo'")));
      debug('\n' + this.as_coffeescript(node));
      info(node = A.BASE.use_statement.run('use 123'));
      debug('\n' + this.as_coffeescript(node));
      info(node = A.BASE.use_statement.run('use :foo'));
      debug('\n' + this.as_coffeescript(node));
      info(node = A.BASE.use_statement.run('use "foo\nbar"'));
      return debug('\n' + this.as_coffeescript(node));
    };
    rv = π.consume(A.TEXT.literal, '"+n"', {
      debugGraph: true
    });
    return njs_fs.writeFileSync('/tmp/test2.dot', rv.state.debugGraphToDot());
  };

  check_nws = function() {
    var CHR, material, parser, test;
    CHR = require('./3-chr');
    test = (require('./test')).test;
    this.$ = {
      'start-of-material': CHR.nws
    };
    material = '\thelo';
    material = 'helo';
    parser = π.alt($['start-of-material']);
    parser = parser.onMatch(function(match) {
      debug(rpr(match));
      throw new Error("xxx");
      return match;
    });
    return debug(test.throws((function() {
      return parser.run(material[0]);
    }), /xxx/));
  };

  try_splice = function() {
    var d, e, splice;
    splice = function(me, you, idx) {
      if (idx == null) {
        idx = 0;
      }

      /* TAINT `splice` is not too good a name for this functionality i guess */

      /* thx to http://stackoverflow.com/a/12190006/256361 */
      Array.prototype.splice.apply(me, [idx, 0].concat(you));
      return me;
    };
    d = ['a', 'b', 'c'];
    e = ['1', '2', '3'];
    splice(d, e, 1);
    return log(d);
  };

  try_escodegen_1 = function() {
    var ESCODEGEN, ESPRIMA, ROUTE, escodegen_options, node;
    ESCODEGEN = require('escodegen');
    ESPRIMA = require('esprima');
    escodegen_options = (require('flowmatic/options'))['escodegen'];
    ROUTE = require('./6-route');
    node = ROUTE.route.run('foo/bar/baz');
    debug(ESCODEGEN.generate(node, escodegen_options));
    return debug(ESCODEGEN.generate(node['value'][0], escodegen_options));
  };

  try_esprima = function() {
    var ESCODEGEN, ESPRIMA;
    ESCODEGEN = require('escodegen');
    ESPRIMA = require('esprima');
    return debug(ESPRIMA.parse('x = null'));
  };

  try_esquery = function() {
    var ESCODEGEN, ESPRIMA, ESQUERY, ESTRAVERSE, literals, node, registry;
    ESCODEGEN = require('escodegen');
    ESPRIMA = require('esprima');
    ESQUERY = require('esquery');
    ESTRAVERSE = require('estraverse');
    node = ESPRIMA.parse("var x = null, y, z;\nfor( var i = 0; i < 10; i++ ){};");
    literals = [];
    registry = [];
    return ESTRAVERSE.traverse(node, {
      enter: function(node, parent) {
        if (node['type'] === 'Literal') {
          node['x-subtype'] = 'yay';
        }
        if (node['x-id'] == null) {
          node['x-id'] = registry.length;
          registry.push(node);
        }
        if (parent != null) {
          node['x-parent-id'] = parent['x-id'];
        }
        return debug(node);
      }
    });
  };

  try_esquery_1 = function() {
    var ESPRIMA, ESQUERY, node, nodes, source;
    ESPRIMA = require('esprima');
    ESQUERY = require('esquery');
    source = "foo[ 'bar' ][ 'baz' ][ 'gnu' ][ 'foo' ][ 'due' ]";
    node = ESPRIMA.parse(source);
    debug(node);
    nodes = ESQUERY.query(node, '[type="Identifier"]');
    info(nodes.length);
    return info(nodes);
  };

  try_escodegen = function() {
    var ESCODEGEN, ESPRIMA, escodegen_options, node, source;
    ESCODEGEN = require('escodegen');
    ESPRIMA = require('esprima');
    escodegen_options = (require('../options'))['escodegen'];
    node = {
      'type': 'Literal',
      'x-subtype': 'phrase',
      'x-verbatim': 'for x in xs',
      'raw': 'for x in xs',
      'value': 'for x in xs'
    };
    node = {
      'type': 'BlockStatement',
      'x-subtype': 'suite',
      'body': [node]
    };
    source = "for( i = f(); i++; i < 100 ){ x = g(); log( i ); }";
    
  node = { type: 'BlockStatement',
            body:
             [ { type: 'ExpressionStatement',
                 expression:
                  { type: 'AssignmentExpression',
                    operator: '=',
                    left: { type: 'Identifier', name: 'x' },
                    right:
                     { type: 'CallExpression',
                       callee: { type: 'Identifier', name: 'g' },
                       arguments: [] } } },
               { type: 'ExpressionStatement',
                 expression:
                  { type: 'CallExpression',
                    callee: { type: 'Identifier', name: 'log' },
                    arguments: [ { type: 'Identifier', name: 'i' } ] } } ] }
  ;
    
  node = { type: 'BlockStatement',
  'x-subtype': 'suite',
  body:
   [ { type: 'ExpressionStatement',
       'x-subtype': 'auto',
       expression:
        { type: 'Literal',
          'x-subtype': 'phrase',
          'x-verbatim': 'if x > 0',
          raw: 'if x > 0',
          value: 'if x > 0' } },
     { type: 'BlockStatement',
       'x-subtype': 'suite',
       body:
        [ { type: 'ExpressionStatement',
            'x-subtype': 'auto',
            expression:
             { type: 'Literal',
               'x-subtype': 'phrase',
               'x-verbatim': 'log \'ok\'',
               raw: 'log \'ok\'',
               value: 'log \'ok\'' } } ] } ] }  ;
    return info(ESCODEGEN.generate(node, escodegen_options));
  };

  if (module.parent == null) {
    try_esquery_1();
    null;
  }

}).call(this);

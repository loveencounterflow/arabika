// Generated by CoffeeScript 1.6.3
(function() {
  var TRM, TYPES, add, alert, arrow, ascii_digits, ascii_name, asciispaces, assignment_lhs, assignment_rhs, badge, bare_function_def_head, bare_name_list, bare_return_statement, basic_ascii_name, comma, consume, csv, debug, difference, division, double_fat_arrow, double_slim_arrow, echo, empty_signature, exp_or_return, expr, expression, exps_or_returns, filled_function_def_head, filled_return_statement, filled_signature, function_def, function_def_head, help, id, info, inline_function_def, inline_function_def_body, log, lws, nocomma, notok, number, ok, one_asciispace, optional_asciispaces, optional_comma, parameter_separator, parse, parser, product, rainbow, return_literal, return_statement, rpr, rv, show, show_parse_result, signature, signature_close, signature_open, single_fat_arrow, single_slim_arrow, source, staged_function_def, sum, sum_expr, test, test_for_comma, test_for_nocomma, two_asciispaces, two_n0_asciispaces, warn, whisper, π, _clean_match,
    __slice = [].slice;

  TYPES = require('coffeenode-types');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'more-experiments';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  rainbow = TRM.rainbow.bind(TRM);

  π = require('coffeenode-packrattle');

  ascii_digits = /[0-9]+/;


  /* Matches basic US-ASCII names with upper- and lower case letters plus digits, where only letters are
  allowed as first character. Does not include *any* punctuation.
   */

  basic_ascii_name = /[a-zA-Z][a-zA-Z0-9]*/;


  /* Like `basic_ascii_name`, but allows for a dash in the middle of a name. */

  ascii_name = π.regex(/[a-zA-Z][a-zA-Z0-9]*[-a-zA-Z0-9]*?[a-zA-Z0-9]+|[a-zA-Z][a-zA-Z0-9]?/);

  one_asciispace = π.regex(/\x20/);

  two_asciispaces = π.regex(/\x20{2}/);


  /* Matches zero or an even number of ASCII space characters (`\x20`). */

  two_n0_asciispaces = π.regex(/(?:\x20{2})*/);


  /* Matches zero or more ASCII space characters (`\x20`). */

  optional_asciispaces = π.regex(/\x20*/);


  /* Matches one or more ASCII space characters (`\x20`). */

  asciispaces = π.regex(/\x20+/);


  /* For the time being, we only recognize U-0020 as linear whitespace: */

  lws = asciispaces;

  test_for_comma = π.regex(/,/);

  test_for_nocomma = π.regex(/[^,]*/);

  id = function(x) {
    return x;
  };

  number = (π.regex(ascii_digits)).onMatch(function(match) {
    return parseInt(match[0], 10);
  });

  comma = test_for_comma.onMatch(function(match) {
    return match[0];
  });

  nocomma = test_for_nocomma.onMatch(function(match) {
    return match[0];
  });

  assignment_lhs = π.alt(ascii_name);

  assignment_rhs = π.alt(expression);

  add = function(total, separator, n) {
    debug('add', total, separator, n);
    return total + n;
  };

  expression = π.reduce(ascii_digits, '+', id, add);

  csv = π.repeatSeparated(nocomma, comma);

  product = π.seq((function() {
    return expr;
  }), lws, '*', lws, (function() {
    return expr;
  }));

  division = π.seq((function() {
    return expr;
  }), lws, '/', lws, (function() {
    return expr;
  }));

  sum = π.seq((function() {
    return expr;
  }), lws, '+', lws, (function() {
    return expr;
  }));

  difference = π.seq((function() {
    return expr;
  }), lws, '-', lws, (function() {
    return expr;
  }));

  sum_expr = π.alt(sum, difference, number);

  expr = π.alt(sum_expr, product, division);

  expr.describe('XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');

  expr.onMatch(function(match) {
    debug(match);
    return ['expr', match];
  });

  single_slim_arrow = π.string('->');

  single_fat_arrow = π.string('=>');

  double_slim_arrow = π.string('<->');

  double_fat_arrow = π.string('<=>');

  arrow = π.alt(single_slim_arrow, single_fat_arrow, double_slim_arrow, double_fat_arrow);

  return_literal = π.string('<-');

  bare_return_statement = return_literal;

  filled_return_statement = π([return_literal, lws, expr]);

  return_statement = π.alt(bare_return_statement, filled_return_statement);

  parameter_separator = π.seq(comma, lws);

  bare_name_list = π.repeatSeparated(ascii_name, parameter_separator);

  signature_open = π.string('(');

  signature_close = π.string(')');

  optional_comma = π.optional(comma);

  empty_signature = π([signature_open, signature_close]);

  filled_signature = π([signature_open, lws, bare_name_list, optional_comma, lws, signature_close]);

  signature = π.alt(empty_signature, filled_signature);

  bare_function_def_head = arrow;

  filled_function_def_head = π([signature, lws, arrow]);

  function_def_head = π.alt(filled_function_def_head, bare_function_def_head);

  exp_or_return = π.alt(return_statement, expr);


  /* TAINT need to separate statements and expressions with semicolons or other punctuation */

  exps_or_returns = π.repeat(π.alt(return_statement, expression), 1);

  inline_function_def_body = π([lws, exp_or_return]);

  inline_function_def = π([function_def_head, π.optional(π([lws, inline_function_def_body]))]);

  staged_function_def = π.string('????????????????????????');

  function_def = π.alt(staged_function_def, inline_function_def);

  source = '2+10+100!!!';

  source = '2+10+100';

  rv = π.consume(π.repeat(π.alt(/[0-9]+/, '+'), 1), source, {
    debugGraph: true
  });

  show_parse_result = function(name, parse_result) {
    var endloc, loc, message, oldloc, prefix, squiggles, state;
    state = parse_result['state'];
    source = state['internal']['text'];
    log(TRM.grey('------------------------------------------------------------------------------'));
    log(TRM.grey(name, rpr(source)));
    if ((message = parse_result['message']) != null) {
      warn(message);
      return warn(source);
    } else {
      loc = state['loc'];
      oldloc = state['oldloc'];
      endloc = state['endloc'];
      squiggles = state.toSquiggles();
      prefix = TRM.white(source.slice(oldloc['pos'], loc['pos']));
      info(TRM.gold(rpr(_clean_match(parse_result['match']))));
      if (loc['pos'] === source.length) {
        return info(ok.concat(prefix));
      } else {
        return info(notok.concat(prefix, TRM.red(TRM.reverse(TRM.bold(source.slice(loc['pos']))))));
      }
    }
  };

  ok = TRM.green(TRM.bold('✓ '));

  notok = TRM.red(TRM.bold('✘ '));

  _clean_match = function(match) {
    var R, element, _i, _len;
    if (!TYPES.isa_list(match)) {
      return match;
    }
    R = [];
    for (_i = 0, _len = match.length; _i < _len; _i++) {
      element = match[_i];
      R.push(_clean_match(element));
    }
    return R;
  };

  parse = function() {
    var P;
    P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return show.apply(null, ['parse'].concat(__slice.call(P)));
  };

  consume = function() {
    var P;
    P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return show.apply(null, ['consume'].concat(__slice.call(P)));
  };

  show = function(method_name, grammar, name, source) {
    var R, parser;
    parser = grammar != null ? grammar[name] : eval(name);
    show_parse_result(name, R = π[method_name](parser, source));
    return R;
  };

  test = function() {
    var grammar;
    grammar = null;
    consume(grammar, 'ascii_digits', '1234');
    consume(grammar, 'ascii_digits', '1234...');
    consume(grammar, 'ascii_name', 'helo');
    consume(grammar, 'ascii_name', 'helo-there');
    consume(grammar, 'ascii_name', '-h');
    consume(grammar, 'ascii_name', 'h-');
    consume(grammar, 'ascii_name', '-helo');
    consume(grammar, 'ascii_name', 'helo-');
    consume(grammar, 'ascii_name', 'h-o');
    consume(grammar, 'ascii_name', 'he-o');
    consume(grammar, 'ascii_name', 'h-lo');
    consume(grammar, 'ascii_name', 'h2-o');
    consume(grammar, 'ascii_name', 'H2-O');
    consume(grammar, 'ascii_name', 'x1');
    consume(grammar, 'ascii_name', 'x12');
    consume(grammar, 'ascii_name', 'helo 1234');
    consume(grammar, 'ascii_name', '');
    consume(grammar, 'ascii_name', '1234');
    consume(grammar, 'number', '1234');
    consume(grammar, 'sum', '1234');
    consume(grammar, 'sum', '1234+1234');
    consume(grammar, 'sum', '1234 +1234');
    consume(grammar, 'sum', '1234 + 1234');
    consume(grammar, 'product', '1234');
    consume(grammar, 'product', '1234*1234');
    consume(grammar, 'product', '1234 *1234');
    consume(grammar, 'product', '1234 * 1234');
    consume(grammar, 'expr', '1234');
    consume(grammar, 'expr', '1234*1234');
    consume(grammar, 'expr', '1234+1234');
    consume(grammar, 'expr', '1234+1234*456');
    consume(grammar, 'expr', '1234 *1234');
    consume(grammar, 'expr', '1234 * 1234');
    consume(grammar, 'expr', '12 * 34 + 56');
    consume(grammar, 'expr', '12 / 34 + 56');
    consume(grammar, 'expr', '12 + 34 * 56');
    consume(grammar, 'expr', '12 + 34 / 56');
    parse(grammar, 'expr', '12 + 34 / 56');
    consume(grammar, 'single_slim_arrow', '->');
    consume(grammar, 'single_slim_arrow', '=>');
    consume(grammar, 'single_fat_arrow', '->');
    consume(grammar, 'single_fat_arrow', '=>');
    consume(grammar, 'single_slim_arrow', '<->');
    consume(grammar, 'single_slim_arrow', '<=>');
    consume(grammar, 'single_fat_arrow', '<->');
    consume(grammar, 'single_fat_arrow', '<=>');
    consume(grammar, 'double_slim_arrow', '<->');
    consume(grammar, 'double_slim_arrow', '<=>');
    consume(grammar, 'double_fat_arrow', '<->');
    consume(grammar, 'double_fat_arrow', '<=>');
    consume(grammar, 'parameter_separator', ',');
    consume(grammar, 'parameter_separator', ' ,');
    consume(grammar, 'parameter_separator', ', ');
    consume(grammar, 'parameter_separator', ',  ');
    consume(grammar, 'bare_name_list', '');
    consume(grammar, 'bare_name_list', '1');
    consume(grammar, 'bare_name_list', '1, 2');
    consume(grammar, 'empty_signature', '()');
    consume(grammar, 'empty_signature', '(   )');
    consume(grammar, 'filled_signature', '()');
    consume(grammar, 'filled_signature', '(   )');
    consume(grammar, 'filled_signature', '( 42 )');
    consume(grammar, 'filled_signature', '( 42, )');
    consume(grammar, 'filled_signature', '( 42, 108 )');
    consume(grammar, 'filled_signature', '( 42, 108, )');
    consume(grammar, 'filled_signature', '( foo )');
    consume(grammar, 'filled_signature', '( foo, )');
    consume(grammar, 'filled_signature', '( foo, bar )');
    consume(grammar, 'filled_signature', '( foo, bar, )');
    consume(grammar, 'filled_signature', '(foo)');
    consume(grammar, 'filled_signature', '(foo,)');
    consume(grammar, 'filled_signature', '(foo, bar)');
    consume(grammar, 'filled_signature', '(foo, bar,)');
    consume(grammar, 'inline_function_def', '->');
    consume(grammar, 'inline_function_def', '=>');
    consume(grammar, 'inline_function_def', '() =>');
    consume(grammar, 'inline_function_def', '( a ) =>');
    consume(grammar, 'inline_function_def', '( a ) <=> 42');
    consume(grammar, 'inline_function_def', '( a ) => <- 42');
    consume(grammar, 'inline_function_def', '( a, ) =>');
    consume(grammar, 'inline_function_def', '( a, b ) =>');
    consume(grammar, 'inline_function_def', '( a, b, ) =>');
    consume(grammar, 'inline_function_def', '( a, 42, ) =>');
    consume(grammar, 'inline_function_def', '( a, 42, ) => <-');
    consume(grammar, 'inline_function_def', '( a, b, ) => <- a + b');
    return consume(grammar, 'inline_function_def', '( a, b, ) <=> a + b');
  };

  test();

  parser = π.string('abc');

  parser = parser.onMatch(function(match, state) {
    warn(rpr(match));
    return ['text', match];
  });

  info(π.parse(parser, 'abcx'));


  /* If 'p1' matches, return that as the result; otherwise, try 'p2', and so on, until finding a match.
  If none of the parsers match, fail.
   */


  /* Verify that 'p' matches, but don't advance the parser's position. Perl calls this a
  "zero-width lookahead".
   */


  /* If 'p' matches, packrattle will no longer backtrack through previous 'alt' alternatives: the parsing
  is "committed" to this branch. (This can be used with 'onFail' to give less ambiguous error messages.)
   */


  /* If 'p' matches, return null as the match result, which will cause it to be omitted from the result
  of any sequence.
   */


  /* Turn a successful match of 'p' into a failure, or a failure into a success (with an empty string as
  the match result).
   */


  /* Match 'p' or return the default value (usually the empty string), succeeding either way. */


  /* Match 'p' multiple times (often written as "p*"). The match result will be an array of all the
  non-null 'p' results. (Note that it's trivial to match zero times, so often you want to set
  'minCount' to 1.)
   */


  /* Match all of the parsers in sequence. The match result will be an array of all of the non-null match
  results.
   */


  /* Like seq, but make an attempt to match 'ignore' before each parser, throwing away the result if it
  matches and ignoring if it doesn't. This is typically used to discard whitespace.
   */


  /* Similar to 'seqIgnore', attempts to match 'ignore' before each iteration of 'p', throwing away
  the result.
   */


  /* Like 'repeatIgnore', but there must be at least one match of 'p', the separator is not optional,
  and the separator is only matched (and discarded) between items.
   */

}).call(this);

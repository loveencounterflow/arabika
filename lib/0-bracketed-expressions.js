// Generated by CoffeeScript 1.6.3
(function() {
  var NEW, TRM, XRE, alert, badge, debug, echo, help, info, log, rainbow, rpr, warn, whisper, π,
    __slice = [].slice;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '﴾0-bracketed-expressions﴿';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  rainbow = TRM.rainbow.bind(TRM);

  π = require('coffeenode-packrattle');

  NEW = require('./NEW');

  XRE = require('./9-xre');

  this.$ = {
    'opener': '⟦',
    'connector': '∿',
    'closer': '⟧'
  };

  this.expression = π.alt(this.bracketed, this.phrases);

  this.$new = function(options, target) {
    var R, get_rule, name, rule_name, value, _ref, _ref1;
    if (options == null) {
      options = {};
    }
    _ref = this.$;
    for (name in _ref) {
      value = _ref[name];
      if (options[name] == null) {
        options[name] = value;
      }
    }
    R = target != null ? target : {};
    R['$'] = options;
    _ref1 = this.$new;
    for (rule_name in _ref1) {
      get_rule = _ref1[rule_name];
      whisper(rule_name);
      R[rule_name] = get_rule(options);
    }
    return R;
  };

  this.$new.bracketed = function($) {
    var R;
    R = (π.seq($['opener'], π.repeat((function(_this) {
      return function() {
        return _this.expression;
      };
    })(this)), $['closer'])).onMatch(function(match) {
      return ['bracketed', match[0], match[1], match[2]];
    });
    return R;
  };

  this.$new.phrases = function($) {
    var R;
    R = (π.repeatSeparated(this.phrase, RegExp("" + (XRE.$_esc($['connector']))))).onMatch(function(match) {
      return ['phrases'].concat(__slice.call(match));
    });
    return R;
  };

  this.$new.phrase = function($) {
    var R, metachrs;
    metachrs = XRE.$_esc($['opener'] + $['connector'] + $['closer']);
    R = (π.regex(RegExp("[^" + metachrs + "]+"))).onMatch(function(match) {
      R = ['phrase', match[0]];
      return R;
    });
    return R;
  };

  (function(self) {
    var name, value, _ref, _results;
    _ref = self.$new(null, self);
    _results = [];
    for (name in _ref) {
      value = _ref[name];
      _results.push(self[name] = value);
    }
    return _results;
  })(this);

  this.$TESTS = {
    '$new: returns new grammar': function(test) {
      return info(this.$new());
    }
  };

  this._ = function() {
    var njs_fs, parse_info, write;
    njs_fs = require('fs');
    write = function(route, content) {
      return njs_fs.writeFileSync(route, content);
    };
    parse_info = π.parse(this.expression, source, {
      debugGraph: true
    });
    if (parse_info['ok']) {
      return info(parse_info['match']);
    } else {
      warn(parse_info['message'] + '\n' + parse_info['state'].toSquiggles().join('\n'));
      return write("/tmp/process.dot", parse_info['state'].debugGraphToDot());
    }
  };

  this._write_graphs = function() {
    var grammar, name, njs_fs, write, _i, _len, _ref, _results;
    njs_fs = require('fs');
    write = function(route, content) {
      return njs_fs.writeFileSync(route, content);
    };
    _ref = 'expression phrase bracketed'.split(/\s+/);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      name = _ref[_i];
      grammar = this[name];
      _results.push(write("/tmp/" + name + ".dot", grammar.toDot()));
    }
    return _results;
  };

  if (module.parent == null) {
    this._();
    this._write_graphs();
  }

}).call(this);

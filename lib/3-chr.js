// Generated by CoffeeScript 1.6.3
(function() {
  var BNP, TRM, XRE, alert, badge, debug, echo, help, info, log, rpr, warn, whisper, ∆í;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'Ô¥æ3-chrÔ¥ø';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  ∆í = require('flowmatic');

  this.$new = ∆í["new"]["new"](this);

  BNP = require('coffeenode-bitsnpieces');

  XRE = require('./9-xre');

  this.$ = {

    /* ASCII Punctuation: */
    'ascii-punctuation': /[-_!"\#%&'(\[{\\}\])*,.\/:;?@]/,

    /* Whitespace: */

    /* Unicode line endings (RegEx should have the global flag set): */
    'newlines': /\r\n|[\n\v\f\r\x85\u2028\u2029]/g,

    /* Unicode linear whitespace: */
    'linear-whitespace': XRE('\\L+'),

    /* Anything but whitespace: */
    'no-whitespace': /[^\s\x85]+/,

    /* Names: */

    /* Leading character in names (excluding sigils): */
    'name-first-chr': XRE('\\p{L}'),

    /* Trailing characters in names: */
    'name-trailing-chrs': XRE('(?:-|\\p{L}|\\d)*'),

    /* Character used to form URL-like routes out of crumbs: */
    'crumbs-joiner': '/',

    /* Sigils may start and classify simple names: */
    'sigils': {
      '@': 'attribute',
      '~': 'system',
      '.': 'hidden',
      '_': 'private',
      '%': 'cached',
      '!': 'attention'
    }
  };

  this.$new.$ascii_punctuation = function(G, $) {
    var R;
    R = ∆í.regex($['ascii-punctuation']);
    return R;
  };

  this.$new.$chr = function(G, $) {
    var R;
    R = ∆í.regex(XRE('.', 'Qs'));
    R = R.onMatch(function(match) {
      return match[0];
    });
    return R;
  };


  /* TAINT `∆í.or` is an expedient here */

  this.$new.chr = function(G, $) {
    var R;
    R = ∆í.or(function() {
      return G.$chr;
    });
    R = R.onMatch(function(match) {
      return ∆í["new"].literal('chr', match, match);
    });
    return R;
  };


  /* TAINT `∆í.or` is an expedient here */

  this.$new.$letter = function(G, $) {
    var R;
    R = ∆í.regex(XRE('\\p{L}'));
    R = R.onMatch(function(match) {
      return match[0];
    });
    return R;
  };

  this.$new.$lws = function(G, $) {

    /* Linear WhiteSpace */
    var R;
    R = ∆í.regex($['linear-whitespace']);
    R = R.onMatch(function(match) {
      return match[0];
    });
    R = R.describe('linear whitespace');
    return R;
  };

  this.$new.lws = function(G, $) {

    /* Linear WhiteSpace */
    var R;
    R = G.$lws.onMatch(function(match) {
      return ∆í["new"].literal('lws', match, match);
    });
    R = R.describe('linear whitespace');
    return R;
  };

  this.$new.ilws = function(G, $) {

    /* invisible LWS */
    var R;
    R = ∆í.drop(∆í.regex($['linear-whitespace']));
    return R;
  };

  this.$new.$nws = function(G, $) {

    /* no WhiteSpace */
    var R;
    R = ∆í.regex($['no-whitespace']);
    return R;
  };

  this.$new.nws = function(G, $) {
    var R;
    R = ∆í.or(function() {
      return G.$nws.onMatch(function(match) {
        return ∆í["new"].literal('nws', match[0], match[0]);
      });
    });
    R = R.describe("no-whitespace");
    return R;
  };

  this.$new.$nl = function(G, $) {
    var R;
    R = ∆í.regex($['newlines']);
    return R;
  };

  this.$new.$name_first_chr = function(G, $) {
    var R;
    R = ∆í.regex($['name-first-chr']);
    R = R.onMatch(function(match) {
      return match[0];
    });
    R = R.describe('first character of name');
    return R;
  };

  this.$new.$name_trailing_chrs = function(G, $) {
    var R;
    R = ∆í.regex($['name-trailing-chrs']);
    R = R.onMatch(function(match) {
      return match[0];
    });
    R = R.describe('trailing characters of name');
    return R;
  };

  this.$new.$name_sigil = function(G, $) {
    var R, key, sigils;
    sigils = ((function() {
      var _results;
      _results = [];
      for (key in $['sigils']) {
        _results.push(XRE.$esc(key));
      }
      return _results;
    })()).join('');
    R = ∆í.regex(XRE("[" + sigils + "]"));
    R = R.onMatch(function(match) {
      return match[0];
    });
    R = R.describe('name');
    return R;
  };

  this.$new.$name = function(G, $) {
    var R;
    R = ∆í.seq(∆í.optional(function() {
      return G.$name_sigil;
    }), (function() {
      return G.$name_first_chr;
    }), (function() {
      return G.$name_trailing_chrs;
    }));
    R = R.onMatch(function(match) {
      return match.join('');
    });
    R = R.describe('name');
    return R;
  };


  /* Run `@$new` to make `@` (`this`) an instance of this grammar with default options: */

  this.$new(this, null);

  this.$TESTS = {
    '$chr: matches code points (instead of code units) and newlines': function(test) {
      test.eq(this.$chr.run('x'), 'x');
      test.eq(this.$chr.run('\r'), '\r');
      test.eq(this.$chr.run('\n'), '\n');
      return test.eq(this.$chr.run('†Äù'), '†Äù');
    },
    'chr: matches code points (instead of code units) and newlines': function(test) {
      test.eq(this.chr.run('x'), ∆í["new"].literal('chr', 'x', 'x'));
      test.eq(this.chr.run('\r'), ∆í["new"].literal('chr', '\r', '\r'));
      test.eq(this.chr.run('\n'), ∆í["new"].literal('chr', '\n', '\n'));
      return test.eq(this.chr.run('†Äù'), ∆í["new"].literal('chr', '†Äù', '†Äù'));
    },
    '$chr: accepts single character, be it one or two code units': function(test) {
      var probe, probes_and_results, result, _i, _len, _ref, _results;
      probes_and_results = [['0', '0'], ['q', 'q'], ['‰∏≠', '‰∏≠'], ['†Äù', '†Äù']];
      _results = [];
      for (_i = 0, _len = probes_and_results.length; _i < _len; _i++) {
        _ref = probes_and_results[_i], probe = _ref[0], result = _ref[1];
        _results.push(test.eq(this.$chr.run(probe), result));
      }
      return _results;
    },
    '$chr: rejects more than a single character': function(test) {
      var probe, probes, _i, _len, _results;
      probes = ['01', 'qwertz', '‰∏≠‰∏≠', '†Äùx'];
      _results = [];
      for (_i = 0, _len = probes.length; _i < _len; _i++) {
        probe = probes[_i];
        _results.push(test.throws(((function(_this) {
          return function() {
            return _this.$chr.run(probe);
          };
        })(this)), /Expected end/));
      }
      return _results;
    },
    '$ascii_punctuation: rejects anything but ASCII punctuation': function(test) {
      var probe, probes, _i, _len, _results;
      probes = ['a', '', '‰∏≠', '†ÄÅ'];
      _results = [];
      for (_i = 0, _len = probes.length; _i < _len; _i++) {
        probe = probes[_i];
        _results.push(test.throws(((function(_this) {
          return function() {
            return _this.$ascii_punctuation.run(probe);
          };
        })(this)), /Expected /));
      }
      return _results;
    },
    'nws: rejects sequences defined as whitespace in Unicode 6.2': function(test) {
      var error, errors, errors_txt, probe, probes, text, _i, _len;
      errors = [];
      probes = ['\u0009', '\u000A', '\u000B', '\u000C', '\u000D', '\u0020', '\u0085', '\u00A0', '\u1680', '\u2000', '\u2001', '\u2002', '\u2003', '\u2004', '\u2005', '\u2006', '\u2007', '\u2008', '\u2009', '\u200A', '\u2028', '\u2029', '\u202F', '\u205F', '\u3000'];
      for (_i = 0, _len = probes.length; _i < _len; _i++) {
        probe = probes[_i];
        try {
          this.nws.run(probe);
        } catch (_error) {
          error = _error;
          if (error['message'] !== 'Expected no-whitespace') {
            throw error;
          }
          continue;
        }
        errors.push(probe);
      }
      if (errors.length !== 0) {
        errors_txt = ((function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = errors.length; _j < _len1; _j++) {
            text = errors[_j];
            _results.push(rpr(text));
          }
          return _results;
        })()).join(', ');
        throw new Error("wrongly recognized as non-whitespace: " + errors_txt);
      }
    },
    'nws: accepts sequences of non-whitespace characters': function(test) {
      var probe, probes, _i, _len, _results;
      probes = ["aeiou", "123/)zRT¬ß", "‰∏≠ÂúãÁöáÂ∏ùüöÇ"];
      _results = [];
      for (_i = 0, _len = probes.length; _i < _len; _i++) {
        probe = probes[_i];
        _results.push(test.eq(this.nws.run(probe), ∆í["new"].literal('nws', probe, probe)));
      }
      return _results;
    },
    'lws: accepts sequences of U+0020': function(test) {
      var probe, probes, _i, _len, _results;
      probes = [' ', '        '];
      _results = [];
      for (_i = 0, _len = probes.length; _i < _len; _i++) {
        probe = probes[_i];
        _results.push(test.eq(this.lws.run(probe), ∆í["new"].literal('lws', probe, probe)));
      }
      return _results;
    },
    'ilws: accepts and drops sequences of U+0020': function(test) {
      var probe, probes, _i, _len, _results;
      probes = [' ', '        '];
      _results = [];
      for (_i = 0, _len = probes.length; _i < _len; _i++) {
        probe = probes[_i];
        _results.push(test.eq(this.ilws.run(probe), null));
      }
      return _results;
    },
    "G$[ 'newlines' ]: splits string with Unicode line endings correctly": function(test) {
      var G;
      G = this;
      return test.eq('1\r\n2\n3\v4\f5\r6\x857\u20288\u20299'.split(this.$['newlines']), ['1', '2', '3', '4', '5', '6', '7', '8', '9']);
    },
    "G$[ 'newlines' ]: allows global replace": function(test) {
      return test.eq('1\r\n2\n3\v4\f5\r6\x857\u20288\u20299'.replace(this.$['newlines'], '#'), '1#2#3#4#5#6#7#8#9');
    },
    '$letter: matches single letters, including 32bit code points': function(test) {
      var probe, probes_and_results, result, _i, _len, _ref, _results;
      probes_and_results = [['q', 'q'], ['‰∏≠', '‰∏≠'], ['†Äù', '†Äù']];
      _results = [];
      for (_i = 0, _len = probes_and_results.length; _i < _len; _i++) {
        _ref = probes_and_results[_i], probe = _ref[0], result = _ref[1];
        _results.push(test.eq(this.$letter.run(probe), result));
      }
      return _results;
    },
    '$letter: rejects anything but single letters': function(test) {
      var probe, probes, _i, _len, _results;
      probes = ['0', '-', '(', 'ÿü', 'xx'];
      _results = [];
      for (_i = 0, _len = probes.length; _i < _len; _i++) {
        probe = probes[_i];
        _results.push(test.throws(((function(_this) {
          return function() {
            return _this.$letter.run(probe);
          };
        })(this)), /Expected/));
      }
      return _results;
    },
    '$name_first_chr: matches first character of names': function(test) {
      var probe, probes, _i, _len, _results;
      probes = ['a', 'A', '†ÄÅ'];
      _results = [];
      for (_i = 0, _len = probes.length; _i < _len; _i++) {
        probe = probes[_i];
        _results.push(test.eq(this.$name_first_chr.run(probe), probe));
      }
      return _results;
    },
    '$name_trailing_chrs: matches trailing characters of names': function(test) {
      var probe, probes, _i, _len, _results;
      probes = ['abc', 'abc-def', 'abc-def-45'];
      _results = [];
      for (_i = 0, _len = probes.length; _i < _len; _i++) {
        probe = probes[_i];
        _results.push(test.eq(this.$name_trailing_chrs.run(probe), probe));
      }
      return _results;
    },
    '$name: matches names': function(test) {
      var probe, probes, _i, _len, _results;
      probes = ['n', 'n0', 'readable-names', 'foo-32'];
      _results = [];
      for (_i = 0, _len = probes.length; _i < _len; _i++) {
        probe = probes[_i];
        _results.push(test.eq(this.$name.run(probe), probe));
      }
      return _results;
    },
    '$name: matches names with sigils': function(test) {
      var probe, probes, _i, _len, _results;
      probes = ['@n', '%n0', '_readable-names', '.foo-32', '~isa'];
      _results = [];
      for (_i = 0, _len = probes.length; _i < _len; _i++) {
        probe = probes[_i];
        whisper(probe);
        _results.push(test.eq(this.$name.run(probe), probe));
      }
      return _results;
    },
    '$name: rejects non-names': function(test) {
      var probe, probes, _i, _len, _results;
      probes = ['034', '-/-', '()', 'ÿü?'];
      _results = [];
      for (_i = 0, _len = probes.length; _i < _len; _i++) {
        probe = probes[_i];
        _results.push(test.throws(((function(_this) {
          return function() {
            return _this.$name.run(probe);
          };
        })(this)), /Expected/));
      }
      return _results;
    }
  };

}).call(this);

// Generated by CoffeeScript 1.6.3
(function() {
  var BNP, NEW, TRM, XRE, alert, badge, debug, echo, help, info, log, rpr, warn, whisper, π;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '﴾3-chr﴿';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  π = require('coffeenode-packrattle');

  BNP = require('coffeenode-bitsnpieces');

  NEW = require('./NEW');

  XRE = require('./9-xre');

  this.$_constants = {
    'ascii-punctuation': "-!\"#%&'()*,./:;?@[\\]_{}",

    /* Sigils may start and classify simple names: */
    'sigils': {
      '.': 'hidden',
      '_': 'private',
      '%': 'cached',
      '!': 'attention'
    }
  };


  /* TAINT `π.alt` is an expedient here */


  /* TAINT no memoizing */

  this.$_ascii_punctuation = π.alt((function(_this) {
    return function() {
      return π.regex(XRE('[' + (XRE.$esc(_this.$_constants['ascii-punctuation'])) + ']'));
    };
  })(this));

  this.$_chr = (π.regex(XRE('.', 'Qs'))).onMatch(function(match) {
    return match[0];
  });


  /* TAINT `π.alt` is an expedient here */

  this.chr = (π.alt(this.$_chr)).onMatch(function(match) {
    return NEW.literal('chr', match, match);
  });


  /* Linear WhiteSpace */

  this.lws = (π.regex(/\x20+/)).onMatch(function(match) {
    return NEW.literal('lws', match[0], match[0]);
  });


  /* invisible LWS */

  this.ilws = π.drop(π.regex(/\x20+/));


  /* no WhiteSpace */

  this.$nws = π.regex(/[^\s\x85]+/);


  /* TAINT better way to chain methods? */

  this.nws = this.$nws.onMatch((function(_this) {
    return function(match) {
      return NEW.literal('nws', match[0], match[0]);
    };
  })(this));

  this.nws = this.nws.describe("no-whitespace");

  this.$TESTS = {
    '$chr: matches code points (instead of code units) and newlines': function(test) {
      test.eq(this.$_chr.run('x'), 'x');
      test.eq(this.$_chr.run('\r'), '\r');
      test.eq(this.$_chr.run('\n'), '\n');
      return test.eq(this.$_chr.run('𠀝'), '𠀝');
    },
    'chr: matches code points (instead of code units) and newlines': function(test) {
      test.eq(this.chr.run('x'), NEW.literal('chr', 'x', 'x'));
      test.eq(this.chr.run('\r'), NEW.literal('chr', '\r', '\r'));
      test.eq(this.chr.run('\n'), NEW.literal('chr', '\n', '\n'));
      return test.eq(this.chr.run('𠀝'), NEW.literal('chr', '𠀝', '𠀝'));
    },
    '$chr: accepts single character, be it one or two code units': function(test) {
      var probe, probes_and_results, result, _i, _len, _ref, _results;
      probes_and_results = [['0', '0'], ['q', 'q'], ['中', '中'], ['𠀝', '𠀝']];
      _results = [];
      for (_i = 0, _len = probes_and_results.length; _i < _len; _i++) {
        _ref = probes_and_results[_i], probe = _ref[0], result = _ref[1];
        _results.push(test.eq(this.$_chr.run(probe), result));
      }
      return _results;
    },
    '$chr: rejects more than a single character': function(test) {
      var probe, probes, _i, _len, _results;
      probes = ['01', 'qwertz', '中中', '𠀝x'];
      _results = [];
      for (_i = 0, _len = probes.length; _i < _len; _i++) {
        probe = probes[_i];
        _results.push(test.throws(((function(_this) {
          return function() {
            return _this.$_chr.run(probe);
          };
        })(this)), /Expected end/));
      }
      return _results;
    },
    '$ascii_punctuation: rejects anything but ASCII punctuation': function(test) {
      var probe, probes, _i, _len, _results;
      probes = ['a', '', '中', '𠀁'];
      _results = [];
      for (_i = 0, _len = probes.length; _i < _len; _i++) {
        probe = probes[_i];
        _results.push(test.throws(((function(_this) {
          return function() {
            return _this.$_ascii_punctuation.run(probe);
          };
        })(this)), /Expected /));
      }
      return _results;
    },
    'nws: rejects sequences defined as whitespace in Unicode 6.2': function(test) {
      var error, errors, errors_txt, probe, probes, text, _i, _len;
      errors = [];
      probes = ['\u0009', '\u000A', '\u000B', '\u000C', '\u000D', '\u0020', '\u0085', '\u00A0', '\u1680', '\u2000', '\u2001', '\u2002', '\u2003', '\u2004', '\u2005', '\u2006', '\u2007', '\u2008', '\u2009', '\u200A', '\u2028', '\u2029', '\u202F', '\u205F', '\u3000'];
      for (_i = 0, _len = probes.length; _i < _len; _i++) {
        probe = probes[_i];
        try {
          this.nws.run(probe);
        } catch (_error) {
          error = _error;
          if (error['message'] !== 'Expected no-whitespace') {
            throw error;
          }
          continue;
        }
        errors.push(probe);
      }
      if (errors.length !== 0) {
        errors_txt = ((function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = errors.length; _j < _len1; _j++) {
            text = errors[_j];
            _results.push(rpr(text));
          }
          return _results;
        })()).join(', ');
        throw new Error("wrongly recognized as non-whitespace: " + errors_txt);
      }
    },
    'nws: accepts sequences of non-whitespace characters': function(test) {
      var probe, probes, _i, _len, _results;
      probes = ["aeiou", "123/)zRT§", "中國皇帝🚂"];
      _results = [];
      for (_i = 0, _len = probes.length; _i < _len; _i++) {
        probe = probes[_i];
        _results.push(test.eq(this.nws.run(probe), NEW.literal('nws', probe, probe)));
      }
      return _results;
    },
    'lws: accepts sequences of U+0020': function(test) {
      var probe, probes, _i, _len, _results;
      probes = [' ', '        '];
      _results = [];
      for (_i = 0, _len = probes.length; _i < _len; _i++) {
        probe = probes[_i];
        _results.push(test.eq(this.lws.run(probe), NEW.literal('lws', probe, probe)));
      }
      return _results;
    },
    'ilws: accepts and drops sequences of U+0020': function(test) {
      var probe, probes, _i, _len, _results;
      probes = [' ', '        '];
      _results = [];
      for (_i = 0, _len = probes.length; _i < _len; _i++) {
        probe = probes[_i];
        _results.push(test.eq(this.ilws.run(probe), null));
      }
      return _results;
    }
  };

}).call(this);

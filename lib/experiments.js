// Generated by CoffeeScript 1.6.3
(function() {
  var A, TRM, alert, badge, debug, echo, glob, help, info, log, name, node, rainbow, rpr, warn, whisper, π,
    __slice = [].slice;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '﴾experiments﴿';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  rainbow = TRM.rainbow.bind(TRM);


  /* https://github.com/isaacs/node-glob */

  glob = require('glob');


  /* https://github.com/loveencounterflow/coffeenode-packrattle,
  forked from https://github.com/robey/packrattle
   */

  π = require('coffeenode-packrattle');

  A = require('./main');

  for (name in A) {
    info(name);
  }


  /* TAINT translation routines should be
  (1) independent from grammar, so we can translate to different targets;
  (2) be modular and extensible, so new forms of expression can implement both new syntax
      and ways of translation to different targets.
  Point (2) is not possible with a `switch`-dispatcher.
   */

  this.as_coffeescript = function(node) {

    /* TAINT makeshift for smooth transition to SpiderMonkey Parser API */
    var content, crumb, crumbs_node, expression_node, identifier_node, left, operator, right, sub_expression, sub_type, type;
    if ((type = node['type']) != null) {
      null;
    } else {
      type = node[0], content = 2 <= node.length ? __slice.call(node, 1) : [];
    }
    switch (type) {
      case 'assignment':
        if (content.length !== 2) {
          throw new Error("expected identifier and expression node, got " + (rpr(content)));
        }
        identifier_node = content[0], expression_node = content[1];
        if ((sub_type = identifier_node[0]) !== 'identifier') {
          throw new Error("expected identifier node, got " + sub_type);
        }
        crumbs_node = ['crumbs', identifier_node[1]];
        return "$v" + (this.as_coffeescript(crumbs_node)) + " = " + (this.as_coffeescript(expression_node));
      case 'crumbs':

        /* TAINT must escape identifier */

        /* TAINT shouldn't we also use variables in the target language? */
        return ((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = content.length; _i < _len; _i++) {
            crumb = content[_i];
            _results.push("[ '" + crumb + "' ]");
          }
          return _results;
        })()).join('');
      case 'expression':

        /* TAINT how to join? */
        return ((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = content.length; _i < _len; _i++) {
            sub_expression = content[_i];
            _results.push(this.as_coffeescript(sub_expression));
          }
          return _results;
        }).call(this)).join(' ');
      case 'Literal':

        /* TAINT better to use node[ 'raw' ]? */
        return rpr(node['value']);
      case 'BinaryExpression':

        /* TAINT wrongly assumes operator has direct equivalent in target language */
        left = node.left, operator = node.operator, right = node.right;
        return "" + (this.as_coffeescript(left)) + " " + operator + " " + (this.as_coffeescript(right));
      case 'text':

        /* TAINT text literal should be kept intact */
        return rpr(content[1]);
      case 'symbol':
        return this.as_coffeescript(['text', '"', content[0], '"']);
      case 'use':

        /* TAINT `use` statement not to be translated */
        return "### `use` statement ###\nuse " + (this.as_coffeescript(content[0]));
      default:
        warn("skipped " + type + " " + (rpr(content)));
        return "???";
    }
  };

  node = A.UNSORTED.assignment.run('xy: 20 + 3');

  info(this.as_coffeescript(node));

  node = A.UNSORTED.assignment.run('foo/bar: 20 + 3');

  info(this.as_coffeescript(node));

  info('\n' + rpr(A.UNSORTED.list.run('[ 3, 10, 200 ]')));

  info('\n' + rpr(A.UNSORTED.list.run('[]')));

  info('\n' + rpr(A.UNSORTED.assignment.run('xy: 20 + 3')));

  info('\n' + rpr(A.UNSORTED.expression.run('3 + 10 + 200')));

  info('\n' + rpr(A.UNSORTED.expression.run('3 * 10 + 200')));

  info('\n' + rpr(A.UNSORTED.expression.run('3 + 10 * 200')));

  info('\n' + rpr(A.UNSORTED.expression.run('42')));

  info(rpr(A.TEXT._single_quote.run("'")));

  info(rpr(A.TEXT._double_quote.run('"')));

  info(rpr(A.TEXT._chr_escaper.run('\\')));

  info(rpr(A.TEXT.simple_escape.run('n')));

  info(rpr(A.TEXT._unicode_hex.run('u4e01')));

  info(rpr(A.TEXT._escaped.run('\\u4e01')));

  info(rpr(A.TEXT._escaped.run('\\n')));

  info(rpr(A.TEXT._nosq.run('abcdef')));

  info(rpr(A.TEXT._nodq.run('ioxuy')));

  info(rpr(A.TEXT._dq_text_literal.run('"foo"')));

  info(rpr(A.TEXT._sq_text_literal.run("'foo'")));

  info(rpr(node = A.TEXT.text_literal.run('"helo"')));

  debug('\n' + this.as_coffeescript(node));

  info(rpr(node = A.TEXT.text_literal.run("'helo'")));

  debug('\n' + this.as_coffeescript(node));

  info(node = A.BASE.use_statement.run('use 123'));

  debug('\n' + this.as_coffeescript(node));

  info(node = A.BASE.use_statement.run('use :foo'));

  debug('\n' + this.as_coffeescript(node));

  info(node = A.BASE.use_statement.run('use "foo\nbar"'));

  debug('\n' + this.as_coffeescript(node));

}).call(this);

// Generated by CoffeeScript 1.6.3
(function() {
  var TRM, addition, alert, as_coffeescript, assignment, badge, debug, echo, empty_list, expression, filled_list, help, ilws, info, list, list_kernel, log, lws, multiplication, name, njs_fs, node, plus, product, rainbow, rpr, some_digits, sum, times, warn, whisper, π, _operation_on_match, _operator_on_match,
    __slice = [].slice;

  njs_fs = require('fs');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'πx';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  rainbow = TRM.rainbow.bind(TRM);

  π = require('coffeenode-packrattle');


  /* some CS 1.7.1 syntax here... */

  some_digits = (π.regex(/\d+/)).onMatch(function(match) {
    return ['number', match[0]];
  });


  /* Linear WhiteSpace */

  lws = (π.regex(/\x20+/)).onMatch(function(match) {
    return ['lws', match[0]];
  });


  /* invisible LWS */

  ilws = π.drop(π.regex(/\x20+/));

  _operator_on_match = function(match) {
    return ['operator', match[0]];
  };

  _operation_on_match = function(match) {
    whisper(match);
    return [match[1][0], match[1][1], match[0], match[2]];
  };

  plus = (π.string('+')).onMatch(_operator_on_match);

  times = (π.string('*')).onMatch(_operator_on_match);


  /*
  possible:
    addition    = π.seq ( -> expression ), ( -> lws ), ( -> plus ), ( -> lws ), ( -> expression )
  not possible:
    addition    = π.seq expression, lws, plus, lws, expression
   */

  addition = (π.seq((function() {
    return expression;
  }), ilws, plus, ilws, (function() {
    return expression;
  }))).onMatch(_operation_on_match);

  multiplication = (π.seq((function() {
    return expression;
  }), ilws, times, ilws, (function() {
    return expression;
  }))).onMatch(_operation_on_match);

  sum = π.alt(addition, some_digits);

  product = π.alt(multiplication, some_digits);

  expression = (π.alt(sum, product)).onMatch(function(match) {
    return ['expression', match];
  });

  info('\n' + rpr(expression.run('3 + 10 + 200')));

  info('\n' + rpr(expression.run('3 * 10 + 200')));

  info('\n' + rpr(expression.run('3 + 10 * 200')));

  info('\n' + rpr(expression.run('42')));

  list_kernel = π.repeatSeparated((function() {
    return expression;
  }), π([',', ilws]));

  empty_list = (π.seq('[', π.optional(ilws), ']')).onMatch(function(match) {
    return ['list'];
  });

  filled_list = (π.seq('[', ilws, π.optional(list_kernel), ilws, ']')).onMatch(function(match) {
    return ['list'].concat(__slice.call(match[1]));
  });

  list = π.alt(empty_list, filled_list);

  info('\n' + rpr(list.run('[ 3, 10, 200 ]')));

  info('\n' + rpr(list.run('[]')));


  /* TAINT does not respected escaped slashes, interpolations */

  name = (π.regex(/^[^0-9][^\s:]*/)).onMatch(function(match) {
    return ['identifier', match[0].split('/')];
  });

  assignment = (π([name, ':', ilws, expression])).onMatch(function(match) {
    return ['assignment', match[0], match[2]];
  });

  info('\n' + rpr(assignment.run('xy: 20 + 3')));


  /* TAINT translation routines should be
  (1) independent from grammar, so we can translate to different targets;
  (2) be modular and extensible, so new forms of expression can implement both new syntax
      and ways of translation to different targets.
  Point (2) is not possible with a `switch`-dispatcher.
   */

  as_coffeescript = function(node) {
    var content, crumb, crumbs, crumbs_txt, expression_node, identifier_node, sub_expression, sub_type, type;
    type = node[0], content = 2 <= node.length ? __slice.call(node, 1) : [];
    debug(type, content);
    switch (type) {
      case 'assignment':
        if (content.length !== 2) {
          throw new Error("expected identifier and expression node, got " + (rpr(content)));
        }
        identifier_node = content[0], expression_node = content[1];
        if ((sub_type = identifier_node[0]) !== 'identifier') {
          throw new Error("expected identifier node, got " + sub_type);
        }
        crumbs = identifier_node[1];

        /* TAINT must escape identifier */

        /* TAINT shouldn't we also use variables in the target language? */
        crumbs_txt = ((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = crumbs.length; _i < _len; _i++) {
            crumb = crumbs[_i];
            _results.push("[ '" + crumb + "' ]");
          }
          return _results;
        })()).join('');
        return "$v" + crumbs_txt + " = " + (as_coffeescript(expression_node));
      case 'expression':

        /* TAINT how to join? */
        return ((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = content.length; _i < _len; _i++) {
            sub_expression = content[_i];
            _results.push(as_coffeescript(sub_expression));
          }
          return _results;
        })()).join(' ');
      case 'number':
        return content[0];
      case 'operator':

        /* TAINT wrongly assumes binary operator */

        /* TAINT wrongly assumes operator has direct equivalent in target language */
        return "" + (as_coffeescript(content[1])) + " " + content[0] + " " + (as_coffeescript(content[2]));
      default:
        warn("skipped " + type + " " + (rpr(content)));
        return "???";
    }
  };

  node = assignment.run('xy: 20 + 3');

  node = assignment.run('foo/bar: 20 + 3');

  node = assignment.run('foo/bar: gnu/cram');

  info(as_coffeescript(node));

}).call(this);

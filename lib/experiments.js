// Generated by CoffeeScript 1.6.3
(function() {
  var TRM, alert, badge, debug, echo, help, info, log, node, rainbow, rpr, warn, whisper, π,
    __slice = [].slice;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'πx';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  rainbow = TRM.rainbow.bind(TRM);

  π = require('coffeenode-packrattle');

  this.some_digits = (π.regex(/[0-9]+/)).onMatch(function(match) {
    return ['number', match[0]];
  });


  /* Linear WhiteSpace */

  this.lws = (π.regex(/\x20+/)).onMatch(function(match) {
    return ['lws', match[0]];
  });


  /* invisible LWS */

  this.ilws = π.drop(π.regex(/\x20+/));

  this._operator_on_match = function(match) {
    return ['operator', match[0]];
  };

  this._operation_on_match = function(match) {
    return [match[1][0], match[1][1], match[0], match[2]];
  };

  this.plus = (π.string('+')).onMatch(this._operator_on_match);

  this.times = (π.string('*')).onMatch(this._operator_on_match);


  /*
  possible:
    addition    = π.seq ( -> expression ), ( -> lws ), ( -> plus ), ( -> lws ), ( -> expression )
  not possible:
    addition    = π.seq expression, lws, plus, lws, expression
   */

  this.addition = (π.seq(((function(_this) {
    return function() {
      return _this.expression;
    };
  })(this)), this.ilws, this.plus, this.ilws, ((function(_this) {
    return function() {
      return _this.expression;
    };
  })(this)))).onMatch(this._operation_on_match);

  this.multiplication = (π.seq(((function(_this) {
    return function() {
      return _this.expression;
    };
  })(this)), this.ilws, this.times, this.ilws, ((function(_this) {
    return function() {
      return _this.expression;
    };
  })(this)))).onMatch(this._operation_on_match);

  this.sum = π.alt(this.addition, this.some_digits);

  this.product = π.alt(this.multiplication, this.some_digits);

  this.expression = (π.alt(this.sum, this.product)).onMatch((function(_this) {
    return function(match) {
      return ['expression', match];
    };
  })(this));

  info('\n' + rpr(this.expression.run('3 + 10 + 200')));

  info('\n' + rpr(this.expression.run('3 * 10 + 200')));

  info('\n' + rpr(this.expression.run('3 + 10 * 200')));

  info('\n' + rpr(this.expression.run('42')));

  this.list_kernel = π.repeatSeparated(((function(_this) {
    return function() {
      return _this.expression;
    };
  })(this)), π([',', this.ilws]));

  this.empty_list = (π.seq('[', π.optional(this.ilws), ']')).onMatch((function(_this) {
    return function(match) {
      return ['list'];
    };
  })(this));

  this.filled_list = (π.seq('[', this.ilws, π.optional(this.list_kernel), this.ilws, ']')).onMatch((function(_this) {
    return function(match) {
      return ['list'].concat(__slice.call(match[1]));
    };
  })(this));

  this.list = π.alt(this.empty_list, this.filled_list);

  info('\n' + rpr(this.list.run('[ 3, 10, 200 ]')));

  info('\n' + rpr(this.list.run('[]')));


  /* TAINT does not respected escaped slashes, interpolations */

  this.nws = (π.regex(/\S+/)).onMatch((function(_this) {
    return function(match) {
      return ['nws', match[0]];
    };
  })(this));

  this.identifier = (π.regex(/^[^0-9][^\s:]*/)).onMatch((function(_this) {
    return function(match) {
      return ['identifier', match[0].split('/')];
    };
  })(this));

  this.assignment = (π([this.identifier, ':', this.ilws, this.expression])).onMatch((function(_this) {
    return function(match) {
      return ['assignment', match[0], match[2]];
    };
  })(this));

  info('\n' + rpr(this.assignment.run('xy: 20 + 3')));


  /* TAINT translation routines should be
  (1) independent from grammar, so we can translate to different targets;
  (2) be modular and extensible, so new forms of expression can implement both new syntax
      and ways of translation to different targets.
  Point (2) is not possible with a `switch`-dispatcher.
   */

  this.as_coffeescript = function(node) {
    var content, crumb, crumbs, crumbs_txt, expression_node, identifier_node, sub_expression, sub_type, type;
    type = node[0], content = 2 <= node.length ? __slice.call(node, 1) : [];
    switch (type) {
      case 'assignment':
        if (content.length !== 2) {
          throw new Error("expected identifier and expression node, got " + (rpr(content)));
        }
        identifier_node = content[0], expression_node = content[1];
        if ((sub_type = identifier_node[0]) !== 'identifier') {
          throw new Error("expected identifier node, got " + sub_type);
        }
        crumbs = identifier_node[1];

        /* TAINT must escape identifier */

        /* TAINT shouldn't we also use variables in the target language? */
        crumbs_txt = ((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = crumbs.length; _i < _len; _i++) {
            crumb = crumbs[_i];
            _results.push("[ '" + crumb + "' ]");
          }
          return _results;
        })()).join('');
        return "$v" + crumbs_txt + " = " + (this.as_coffeescript(expression_node));
      case 'expression':

        /* TAINT how to join? */
        return ((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = content.length; _i < _len; _i++) {
            sub_expression = content[_i];
            _results.push(this.as_coffeescript(sub_expression));
          }
          return _results;
        }).call(this)).join(' ');
      case 'number':
        return content[0];
      case 'operator':

        /* TAINT wrongly assumes binary operator */

        /* TAINT wrongly assumes operator has direct equivalent in target language */
        return "" + (this.as_coffeescript(content[1])) + " " + content[0] + " " + (this.as_coffeescript(content[2]));
      case 'text':

        /* TAINT text literal should be kept intact */
        return rpr(content[1]);
      case 'symbol':

        /* TAINT text literal should be kept intact */
        whisper(content);
        return rpr(content[1]);
      case 'use':

        /* TAINT `use` statement not to be translated */
        return "### `use` statement ###\nuse " + (this.as_coffeescript(content[0]));
      default:
        warn("skipped " + type + " " + (rpr(content)));
        return "???";
    }
  };

  node = this.assignment.run('xy: 20 + 3');

  info(this.as_coffeescript(node));

  node = this.assignment.run('foo/bar: 20 + 3');

  info(this.as_coffeescript(node));

  this.single_quote = π.string("'");

  this.double_quote = π.string('"');

  this.nosq = (π.alt(((function(_this) {
    return function() {
      return _this.escaped;
    };
  })(this)), /[^']+/)).onMatch(function(match) {
    return match[0];
  });

  this.nodq = (π.alt(((function(_this) {
    return function() {
      return _this.escaped;
    };
  })(this)), /[^"]+/)).onMatch(function(match) {
    return match[0];
  });

  this.chr_escaper = π.string('\\');

  this.unicode4_escape = π.string('u');

  this._sq_text_literal = π.seq(this.single_quote, this.nosq, this.single_quote);

  this._dq_text_literal = π.seq(this.double_quote, this.nodq, this.double_quote);


  /* TAINT maybe we should *not* un-escape anything; better for translation */

  this.text_literal = (π.alt(this._sq_text_literal, this._dq_text_literal)).onMatch((function(_this) {
    return function(match) {
      return ['text'].concat(__slice.call(match));
    };
  })(this));

  this.simple_escape = (π.regex(/[bfnrt]/)).onMatch((function(_this) {
    return function(match) {
      return _this.escape_table[match[0]];
    };
  })(this));

  this.escape_table = {
    b: '\b',
    f: '\f',
    n: '\n',
    r: '\r',
    t: '\t'
  };


  /* TAINT String conversion method dubious; will fail outside of Unicode BMP */

  this.unicode_hex = (π.seq(this.unicode4_escape, /[0-9a-fA-F]{4}/)).onMatch((function(_this) {
    return function(match) {
      return String.fromCharCode('0x' + match[1]);
    };
  })(this));

  this.escaped = (π.seq(this.chr_escaper, π.alt(this.simple_escape, this.unicode_hex, /./))).onMatch((function(_this) {
    return function(match) {
      return match[1];
    };
  })(this));

  this._symbol_sigil = π.string(':');

  this.symbol = (π.seq(this._symbol_sigil, this.nws)).onMatch((function(_this) {
    return function(match) {
      return ['symbol', match[1][1]];
    };
  })(this));

  this._use_keyword = π.string('use');

  this.use_argument = π.alt(this.symbol, this.some_digits, this.text_literal);

  this.use_statement = π.seq(this._use_keyword, this.ilws, this.use_argument);

  info(rpr(this.single_quote.run("'")));

  info(rpr(this.double_quote.run('"')));

  info(rpr(this.chr_escaper.run('\\')));

  info(rpr(this.simple_escape.run('n')));

  info(rpr(this.unicode_hex.run('u4e01')));

  info(rpr(this.escaped.run('\\u4e01')));

  info(rpr(this.escaped.run('\\n')));

  info(rpr(this.nosq.run('abcdef')));

  info(rpr(this.nodq.run('ioxuy')));

  info(rpr(this.text_literal.run('"helo"')));

  info(rpr(this.text_literal.run("'helo'")));

  info(rpr(this._dq_text_literal.run('"foo"')));

  info(rpr(this._sq_text_literal.run("'foo'")));

  info(node = this.use_statement.run('use 123'));

  debug(this.as_coffeescript(node));

  info(node = this.use_statement.run('use :foo'));

  debug(this.as_coffeescript(node));

  info(node = this.use_statement.run('use "foo\nbar"'));

  debug(this.as_coffeescript(node));

}).call(this);

// Generated by CoffeeScript 1.7.1
(function() {
  var TEXT, TRM, XRE, alert, badge, debug, echo, help, info, log, rpr, warn, whisper, ƒ;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '﴾5-quantity﴿';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  ƒ = require('flowmatic');

  XRE = require('./XRE');

  TEXT = require('coffeenode-text');

  this.options = {
    CHR: require('./3-CHR')
  };

  this.constructor = function(G, $) {
    G.helpers._normalize_newlines = function(source) {

      /* Make sure that source
      * contains only `\n` linebreaks
      * ends with a single `\n`
       */
      source = source.replace($.CHR.$['newlines'], '\n');
      source = source.replace(/\n*$/, '\n');
      return source;
    };
    G.helpers._lines_of = function(source) {

      /* Make sure that source contains only `\n` linebreaks; then, split source into lines. */
      var R;
      source = source.replace($.CHR.$['newlines'], '\n');
      source = source.replace(/\s*$/, '');
      R = source.split(/\n/);
      return R;
    };
    G.helpers._parts_of = function(source) {

      /* TAINT does not honor escaped quotes */
      var R, idx, _i, _ref;
      R = source.split(/(\#\#\#|\#|"""|'''|"|')/);

      /* Remove empty strings: */
      for (idx = _i = _ref = R.length - 1; _i >= 0; idx = _i += -1) {
        if (R[idx] === '') {
          R.splice(idx, 1);
        }
      }
      return R;
    };
    G.helpers.walk_chunkify_events_1 = function(source, handler) {
      var last_type, line, line_idx, lines, part, part_idx, parts, type, _i, _j, _len, _len1;
      type = 'other';
      last_type = type;
      lines = G.helpers._lines_of(source);
      for (line_idx = _i = 0, _len = lines.length; _i < _len; line_idx = ++_i) {
        line = lines[line_idx];
        handler(null, 'newline');
        if (type === 'eol-comment') {
          type = 'other';
        }
        parts = G.helpers._parts_of(line);
        for (part_idx = _j = 0, _len1 = parts.length; _j < _len1; part_idx = ++_j) {
          part = parts[part_idx];
          switch (part) {
            case '###':
              if (type === 'block-comment') {
                type = 'other';
              } else if (type === 'other') {
                type = 'block-comment';
              }
              break;
            case '#':
              if (type === 'other') {
                type = 'eol-comment';
              }
              break;
            case '"""':
              if (type === 'triple-dq') {
                type = 'other';
              } else if (type === 'other') {
                type = 'triple-dq';
              }
              break;
            case "'''":
              if (type === 'triple-sq') {
                type = 'other';
              } else if (type === 'other') {
                type = 'triple-sq';
              }
              break;
            case '"':
              if (type === 'single-dq') {
                type = 'other';
              } else if (type === 'other') {
                type = 'single-dq';
              }
              break;
            case "'":
              if (type === 'single-sq') {
                type = 'other';
              } else if (type === 'other') {
                type = 'single-sq';
              }
          }
          if ((type === 'other') && (last_type !== 'other') && (last_type !== 'eol-comment')) {
            handler(null, last_type, part);
          } else {
            handler(null, type, part);
          }
          last_type = type;
        }
      }
      handler(null, null);
      return null;
    };
    G.helpers.walk_chunkify_events_2 = function(source, handler) {
      var buffer, last_type, send_buffer;
      buffer = [];
      last_type = null;
      send_buffer = function() {
        if (buffer.length !== 0) {
          handler(null, last_type, buffer.join(''));
        }
        return buffer.length = 0;
      };
      G.helpers.walk_chunkify_events_1(source, function(error, type, content) {
        if (error != null) {
          throw error;
        }
        if (type === null) {
          send_buffer();
          handler(null, 'newline');
          return handler(null, null);
        }
        if (type === 'newline') {
          if ((last_type === 'other') || (last_type === 'eol-comment')) {
            send_buffer();
            handler(null, 'newline');
            return;
          }
          if (last_type !== null) {
            buffer.push('\n');
            type = last_type;
          }
          return;
        }
        if ((last_type !== null) && (type !== last_type)) {
          send_buffer();
        }
        last_type = type;
        return buffer.push(content);
      });
      return null;
    };
    G.helpers.walk_chunkify_events_3 = function(source, handler) {
      var adjust_content_level, closer, connector, dent, dent_length, dent_matcher, last_level, last_type, level, opener;
      last_type = null;

      /* TAINT simplified setup */
      level = 0;
      last_level = level;
      dent = '  ';
      dent_length = dent.length;
      dent_matcher = RegExp("^(?:" + (XRE.$esc(dent)) + ")*");
      opener = '(';
      connector = ';';
      closer = ')';
      adjust_content_level = function(content) {
        var indentation;
        indentation = (content.match(dent_matcher))[0];
        level = indentation.length / dent_length;
        whisper(level, level - last_level, rpr(content));
        content = content.replace(indentation, '');
        if (level !== Math.floor(level)) {
          return handler(new Error("illegal indentation on line #xxx: " + (rpr(content))));
        }
        if (last_level > level) {
          content = (TEXT.repeat(closer, last_level - level)) + content;
        } else if (last_level < level) {
          content = (TEXT.repeat(opener, level - last_level)) + content;
        } else {
          content = connector + content;
        }
        last_level = level;
        return content;
      };
      G.helpers.walk_chunkify_events_2(source, function(error, type, content) {
        if (error != null) {
          throw error;
        }

        /* Pass through events that are irrelevant for indentation: */
        if ((type !== 'other') && (type !== 'newline')) {
          return handler(null, type, content);
        }
        if (type === 'other' && last_type === 'newline') {
          content = adjust_content_level(content);
        }
        if (content != null) {
          handler(null, type, content);
        } else {
          handler(null, type);
        }
        last_type = type;
      });
      return null;
    };
    G.helpers.as_bracketed = function(source) {
      var R;
      R = [];
      G.helpers.walk_chunkify_events_3(source, function(error, type, content) {
        if (error != null) {
          throw error;
        }
        if (type !== 'newline') {
          return R.push(content);
        }
      });
      return R.join('');
    };
    G.tests._sources = ["#!/whatever\nsomething # a comment # with hashes\n# another comment\nsomething else\nd:\n  a: \"\"\"helo\n    world\"\"\"# 123\n  b:\n    ba: 65\n    bb: 66\n    bc: 67\n\nloop\n  x: _ + 1\n  break\n### a longer comment\n  taking up 2 lines ###\nlog \"message\" + 'foo'", "d:\n  a: \"\"\"helo\n    world\"\"\"\n  b:\n    ba: 65\n    bb: 66\n    bc: 67", "d:\n  a: 64\n  b:\n    ba: 65\n    bb: 66\n    bc:\n      bca: 68\ne: 69", ''];
    G.tests._show_type_and_content = function(error, type, content) {
      if (error != null) {
        throw error;
      }
      return info(TEXT.flush_right(type, 15), content != null ? TRM.gold(rpr(content)) : '');
    };
    G.tests['_helpers.walk_chunkify_events_3 (0)'] = function(test) {
      var source;
      source = G.tests._sources[0];
      return G.helpers.walk_chunkify_events_3(source, function(error, type, content) {
        return G.tests._show_type_and_content(error, type, content);
      });
    };
    G.tests['helpers.walk_chunkify_events_1 (1)'] = function(test) {
      var source;
      source = G.tests._sources[1];
      return G.helpers.walk_chunkify_events_1(source, function(error, type, content) {
        return G.tests._show_type_and_content(error, type, content);
      });
    };
    G.tests['helpers.walk_chunkify_events_2 (1)'] = function(test) {
      var source;
      source = G.tests._sources[1];
      return G.helpers.walk_chunkify_events_2(source, function(error, type, content) {
        return G.tests._show_type_and_content(error, type, content);
      });
    };
    G.tests['helpers.walk_chunkify_events_3 (1)'] = function(test) {
      var source;
      source = G.tests._sources[1];
      return G.helpers.walk_chunkify_events_3(source, function(error, type, content) {
        return G.tests._show_type_and_content(error, type, content);
      });
    };
    G.tests['helpers.as_bracketed (1)'] = function(test) {
      var source;
      source = G.tests._sources[1];
      return debug(rpr(G.helpers.as_bracketed(source)));
    };
    G.tests['_helpers.as_bracketed (0)'] = function(test) {
      var source;
      source = G.tests._sources[0];
      return debug(rpr(G.helpers.as_bracketed(source)));
    };
    return G.tests['_helpers.as_bracketed (2)'] = function(test) {
      var source;
      source = G.tests._sources[2];
      return debug(rpr(G.helpers.as_bracketed(source)));
    };
  };

  ƒ["new"].consolidate(this);

}).call(this);

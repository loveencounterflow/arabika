// Generated by CoffeeScript 1.7.1
(function() {
  var STEP, TEXT, TRM, XRE, alert, badge, debug, echo, help, info, log, rpr, warn, whisper, ƒ;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '﴾0-preprocessing﴿';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  ƒ = require('flowmatic');

  XRE = require('./XRE');

  TEXT = require('coffeenode-text');

  STEP = require('coffeenode-step');

  this.options = {
    CHR: require('./3-CHR')
  };

  this.constructor = function(G, $) {
    G.helpers.new_event = function(type, position, content, has_newline) {
      var R;
      R = {
        'type': type,
        'position': position,
        'content': content,
        'has-newline': has_newline,
        'level-delta': null,
        'level': null
      };
      return R;
    };
    G.helpers._normalize_newlines = function(source) {

      /* Make sure that source
      * contains only `\n` linebreaks
      * ends with a single `\n`
       */
      source = source.replace($.CHR.$['newlines'], '\n');
      source = source.replace(/\n*$/, '\n');
      return source;
    };
    G.helpers._lines_of = function(source) {

      /* Make sure that source contains only `\n` linebreaks; then, split source into lines. */
      var R;
      source = source.replace($.CHR.$['newlines'], '\n');
      source = source.replace(/\s*$/, '');
      R = source.split(/\n/);
      return R;
    };
    G.helpers._parts_of = function(source) {

      /* TAINT does not honor escaped quotes */
      var R, idx, _i, _ref;
      R = source.split(/(\#\#\#|\#|"""|'''|"|')/);

      /* Remove empty strings: */
      for (idx = _i = _ref = R.length - 1; _i >= 0; idx = _i += -1) {
        if (R[idx] === '') {
          R.splice(idx, 1);
        }
      }
      return R;
    };
    G.helpers.step_chunkify_events = function(source, handler) {
      var last_part_idx, line, line_idx, lines, part, part_idx, parts, type, _i, _j, _len, _len1;
      type = 'other';
      lines = G.helpers._lines_of(source);
      for (line_idx = _i = 0, _len = lines.length; _i < _len; line_idx = ++_i) {
        line = lines[line_idx];
        if (type === 'eol-comment') {
          type = 'other';
        }
        parts = G.helpers._parts_of(line);
        last_part_idx = parts.length - 1;
        for (part_idx = _j = 0, _len1 = parts.length; _j < _len1; part_idx = ++_j) {
          part = parts[part_idx];
          switch (part) {
            case '###':
              if (type === 'block-comment') {
                type = 'other';
              } else if (type === 'other') {
                type = 'block-comment';
              }
              break;
            case '#':
              if (type === 'other') {
                type = 'eol-comment';
              }
              break;
            case '"""':
              if (type === 'triple-dq') {
                type = 'other';
              } else if (type === 'other') {
                type = 'triple-dq';
              }
              break;
            case "'''":
              if (type === 'triple-sq') {
                type = 'other';
              } else if (type === 'other') {
                type = 'triple-sq';
              }
              break;
            case '"':
              if (type === 'single-dq') {
                type = 'other';
              } else if (type === 'other') {
                type = 'single-dq';
              }
              break;
            case "'":
              if (type === 'single-sq') {
                type = 'other';
              } else if (type === 'other') {
                type = 'single-sq';
              }
          }
          handler(null, type, part, part_idx === last_part_idx);
        }
      }
      handler(null, null, null, null, null);
      return null;
    };
    G.helpers.step_events = function(source, handler) {
      var is_fenced, stepper;
      stepper = STEP.call_back(G.helpers.step_chunkify_events, source);
      is_fenced = {
        'block-comment': 1,
        'triple-dq': 1,
        'triple-sq': 1,
        'single-dq': 1,
        'single-sq': 1
      };
      STEP.triplets(stepper, function(error, last_value, this_value, next_value) {
        var last_type, next_type, this_content, this_has_nl, this_position, this_type;
        if (error != null) {
          return handler(error);
        }
        if (last_value === null) {
          return handler(null, null);
        }
        this_position = 'middle';
        last_type = last_value[0];
        this_type = this_value[0], this_content = this_value[1], this_has_nl = this_value[2];
        next_type = next_value[0];

        /* Correct early ending of fenced constructs such as `'quoted strings'`: */
        if (is_fenced[last_type]) {
          if (this_type !== last_type) {
            this_position = 'stop';
            this_type = last_type;
          }
        } else if (is_fenced[this_type]) {
          if (this_type !== last_type) {
            this_position = 'start';
          } else {
            this_position = 'middle';
          }
        } else {
          this_position = 'other';
        }
        return handler(null, G.helpers.new_event(this_type, this_position, this_content, this_has_nl));
      });
      return null;
    };
    G.helpers.step_events_with_levels = function(source, handler) {
      var adjust_level, dent, dent_length, dent_matcher, had_newline, has_newline, last_level, level, set_level;
      level = 0;
      last_level = level;

      /* TAINT simplified and non-parametrized implementation of indentation */
      has_newline = true;
      had_newline = had_newline;
      dent = ' ';
      dent_length = dent.length;
      dent_matcher = RegExp("^(?:" + (XRE.$esc(dent)) + ")*");
      adjust_level = function(event, content) {

        /* TAINT must complain when extra whitespace found */
        var indentation;
        content = event['content'];
        indentation = (content.match(dent_matcher))[0];
        level = indentation.length / dent_length / 2;
        if (level !== Math.floor(level)) {
          return handler(new Error("illegal indentation on line #xxx: " + (rpr(content))));
        }
        content = content.replace(indentation, '');
        event['content'] = content;
        return set_level(event);
      };
      set_level = function(event) {
        event['level'] = level;
        event['level-delta'] = level - last_level;
        last_level = level;
        had_newline = has_newline;
        return null;
      };
      G.helpers.step_events(source, function(error, event) {
        var content, position, type;
        if (error != null) {
          throw error;
        }
        if (event === null) {
          return handler(null, null);
        }
        type = event.type, position = event.position, content = event.content, has_newline = event['has-newline'];
        if ((!had_newline) || type !== 'other') {
          set_level(event);
          return handler(null, event);
        }
        if (had_newline) {
          adjust_level(event);
        }
        return handler(null, event);
      });
      return null;
    };
    G.helpers.as_bracketed = function(source) {

      /* TAINT must parametrize these */
      var R, closer, opener;
      opener = '(';
      closer = ')';
      R = [];
      G.helpers.step_events_with_levels(source, function(error, event) {
        var content, has_newline, idx, level_delta, type, _i, _j;
        if (error != null) {
          throw error;
        }
        if (event === null) {
          return R;
        }
        type = event.type, content = event.content, level_delta = event['level-delta'], has_newline = event['has-newline'];
        if (level_delta > 0) {
          for (idx = _i = 0; 0 <= level_delta ? _i < level_delta : _i > level_delta; idx = 0 <= level_delta ? ++_i : --_i) {
            R.push(opener);
          }
          R.push(content);
        } else if (level_delta < 0) {
          R.push(content);
          for (idx = _j = level_delta; level_delta <= 0 ? _j < 0 : _j > 0; idx = level_delta <= 0 ? ++_j : --_j) {
            R.push(closer);
          }
        } else {
          R.push(content);
        }
        if (has_newline) {
          return R.push('\n');
        }
      });
      return R.join('');
    };
    G.tests._sources = ["#!/whatever\nsomething # a comment # with hashes\n# another comment\nsomething else\nd:\n  a: \"\"\"helo\n    world\"\"\"# 123\n  b:\n    ba: 65\n    bb: 66\n    bc: 67\n\nloop\n  x: _ + 1\n  break\n### a longer comment\n  taking up 2 lines ###\nlog \"message\" + 'foo'", "d:\n  a: \"\"\"helo # ###\n    world\"\"\"\n  b:\n\n    ba: 'A(B)C'# comment\n    bb: ''\n    bc: 67\ne: 42\nf\n  ### comment ###\n  'foo'", "d:\n  a: 64\n  b:\n    ba: 65\n    bb: 66\n    bc:\n      bca: 68\ne: 69", ''];
    G.tests._show_type_and_content = function(error, type, position, content) {
      var TYPES, name, value;
      TYPES = require('coffeenode-types');
      if (error != null) {
        throw error;
      }
      if (TYPES.isa_pod(type)) {
        return info(((function() {
          var _results;
          _results = [];
          for (name in type) {
            value = type[name];
            _results.push("" + name + ": " + value);
          }
          return _results;
        })()).join(', '));
      }
      if (arguments.length <= 3) {
        content = position;
        return info(TEXT.flush_right(type, 10), content != null ? TRM.gold(rpr(content)) : '');
      }
      return info(TEXT.flush_right(type, 10), TEXT.flush_left(position, 8), content != null ? TRM.gold(rpr(content)) : '');
    };
    G.tests['helpers.step_chunkify_events (1)'] = function(test) {
      var source;
      source = G.tests._sources[1];
      return G.helpers.step_chunkify_events(source, function(error, type, content) {
        return G.tests._show_type_and_content(error, type, content);
      });
    };
    G.tests['helpers.step_events (1)'] = function(test) {
      var source;
      source = G.tests._sources[1];
      return G.helpers.step_events(source, function(error, event) {
        return G.tests._show_type_and_content(error, event);
      });
    };
    G.tests['helpers.step_events_with_levels (1)'] = function(test) {
      var source;
      source = G.tests._sources[1];
      return G.helpers.step_events_with_levels(source, function(error, event) {
        return G.tests._show_type_and_content(error, event);
      });
    };
    return G.tests['helpers.as_bracketed (1)'] = function(test) {
      var source;
      source = G.tests._sources[1];
      return debug(JSON.stringify(G.helpers.as_bracketed(source)));
    };
  };

  ƒ["new"].consolidate(this);

}).call(this);

// Generated by CoffeeScript 1.7.1

/*

[Whitespace in Unicode 6.3](http://en.wikipedia.org/wiki/Whitespace_character):

Linear:

  U+0009  HT, Horizontal Tab
  U+0020  space
  U+00A0  no-break space
  U+1680  ogham space mark
  U+2000  en quad
  U+2001  em quad
  U+2002  en space
  U+2003  em space
  U+2004  three-per-em space
  U+2005  four-per-em space
  U+2006  six-per-em space
  U+2007  figure space
  U+2008  punctuation space
  U+2009  thin space
  U+200A  hair space
  U+202F  narrow no-break space
  U+205F  medium mathematical space
  U+3000  ideographic space

Line breaking:
  U+000A  LF, Line feed
  U+000B  VT, Vertical Tab
  U+000C  FF, Form feed
  U+000D  CR, Carriage return
  U+0085  NEL, Next line
  U+2028  line separator
  U+2029  paragraph separator
 */

(function() {
  var BNP, TRM, XRE, XRegExp, alert, badge, debug, echo, help, info, log, rainbow, rpr, warn, whisper,
    __slice = [].slice;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '﴾9-xre﴿';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  rainbow = TRM.rainbow.bind(TRM);

  BNP = require('coffeenode-bitsnpieces');


  /* See:
    https://github.com/loveencounterflow/xregexp3
    https://github.com/slevithan/xregexp/wiki/Roadmap
    https://gist.github.com/slevithan/2630353
    http://blog.stevenlevithan.com/archives/javascript-regex-and-unicode
   */

  XRegExp = require('xregexp3');


  /* Always allow expressions like `\p{...}` to match beyond the Unicode BMP: */


  /* Always allow new extensions: */

  XRegExp.install('extensibility');

  XRegExp.addToken(/\\u{([0-9A-Fa-f]{1,6})}/, (function() {
    var as_dec, as_hex, pad;
    pad = function(literal) {
      while (literal.length < 4) {
        '0' + literal;
      }
      return literal;
    };
    as_dec = function(literal) {
      return parseInt(literal, 16);
    };
    as_hex = function(n) {
      return (parseInt(n, 10)).toString(16);
    };
    return function(match, scope, flags) {
      var cid, lead_surrogate, offset, trail_surrogate;
      cid = as_dec(match[1]);
      if (cid > 0x10FFFF) {
        throw new SyntaxError("invalid Unicode code point " + match[0]);
      }

      /* Converting to \uNNNN avoids needing to escape the character and keep it separate
      from preceding tokens:
       */
      if (cid <= 0xFFFF) {
        return "\\u" + (pad(as_hex(cid)));
      }
      offset = cid - 0x10000;
      lead_surrogate = pad(as_hex(0xD800 + (offset >> 10)));
      trail_surrogate = pad(as_hex(0xDC00 + (offset & 0x3FF)));
      return "\\u" + lead_surrogate + "\\u" + trail_surrogate;
    };
  })(), {
    scope: 'all'
  });


  /* Add the Q flag that makes the dot match all code units;
  see http://www.regular-expressions.info/dot.html
   */

  XRegExp.addToken(/\./, function(match, scope, flags) {
    var dot;
    dot = /s/.test(flags) ? '[\\s\\S]' : '.';
    return "(?:[\\ud800-\\udbff][\\udc00-\\udfff]|" + dot + ")";
  }, {
    scope: 'default',
    flag: 'Q'
  });


  /* Add the \L escape that matches all linear whitespace: */

  XRegExp.addToken(/\\L/, function(match, scope, flags) {
    return "[\\u0009\\u0020\\u00A0\\u1680\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000]";
  }, {
    scope: 'all'
  });


  /* Add the U (ungreedy) flag from PCRE and RE2, which reverses greedy and lazy quantifiers: */

  XRegExp.addToken(/([?*+]|{\d+(?:,\d*)?})(\??)/, function(match) {
    return match[1] + (match[2] ? '' : '?');
  }, {
    flag: 'U'
  });

  module.exports = XRE = function() {
    var P;
    P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return XRegExp.apply(null, P);
  };


  /* TAINT use method offered by XRegExp */

  XRE.$esc = BNP.escape_regex.bind(BNP);

  XRE.$TESTS = {
    '(all): with flag `A`, `\\p{}` expressions match astral characters': function(test) {
      var matcher;
      matcher = XRegExp('\\pL', 'A');
      return test.eq(('𠀝'.match(matcher))[0], '𠀝');
    },
    '(all): even without flag `u`, `\\u{}` expressions match (astral) characters by codepoint': function(test) {
      test.eq(('〇𠀝x'.match(XRegExp('\\u{3007}')))[0], '〇');
      return test.eq(('〇𠀝x'.match(XRegExp('\\u{2001d}')))[0], '𠀝');
    },
    '(all): even without flag `u`, `\\uXXXX` expressions match BMP characters by codepoint': function(test) {
      return test.eq(('〇𠀝x'.match(XRegExp('\\u3007')))[0], '〇');
    },
    '(all): even without flag `u`, `\\u{}` is rejected when argument is not a hexadecimal digit': function(test) {
      test.throws((function() {
        return '〇𠀝x'.match(XRegExp('\\u{}'));
      }), /Invalid/);
      return test.throws((function() {
        return '〇𠀝x'.match(XRegExp('\\u{xxx}'));
      }), /Invalid/);
    },
    '(all): even without flag `u`, `\\u{}` is rejected when argument is beyond limits': function(test) {
      return test.throws((function() {
        return '〇𠀝x'.match(XRegExp('\\u{201234}'));
      }), /invalid Unicode code point/);
    },
    '(all): `\\L` matches linear whitespace': function(test) {
      test.ok((XRegExp('\\L')).test(' '));
      test.ok((XRegExp('\\L')).test('\t'));
      return test.ok((XRegExp('\\L')).test('\u3000'));
    },
    '(all): `\\L+` matches stretches of linear whitespace': function(test) {
      test.eq((' \t '.match(XRegExp('\\L+')))[0], ' \t ');
      test.eq(('\t\t\t\t'.match(XRegExp('\\L+')))[0], '\t\t\t\t');
      return test.eq(('\u3000 \t'.match(XRegExp('\\L+')))[0], '\u3000 \t');
    },
    '(all): `\\L` does not match other characters than linear whitespace': function(test) {
      test.ok(!(XRegExp('\\L')).test('x'));
      test.ok(!(XRegExp('\\L')).test('\n'));
      return test.ok(!(XRegExp('\\L')).test('\r'));
    },
    '(`Q` flag): make dot match code points (instead of code units)': function(test) {
      return test.eq(('𠀝x'.match(XRegExp('.', 'Q')))[0], '𠀝');
    },
    '(`Q` flag): dot matches code units without flag': function(test) {
      return test.eq(('𠀝x'.match(XRegExp('.')))[0], '\ud840');
    },
    '(`Q` flag): respects `s` flag': function(test) {
      test.eq(('𠀁x\nabc'.match(XRegExp('.+')))[0], '𠀁x');
      test.eq(('𠀁x\nabc'.match(XRegExp('.+', 'Q')))[0], '𠀁x');
      test.eq(('𠀁x\nabc'.match(XRegExp('.+', 'Qs')))[0], '𠀁x\nabc');
      return test.eq(('𠀁x\nabc'.match(XRegExp('.+', 's')))[0], '𠀁x\nabc');
    }
  };

}).call(this);

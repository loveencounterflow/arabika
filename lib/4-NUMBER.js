// Generated by CoffeeScript 1.7.1
(function() {
  var TRM, alert, badge, debug, echo, help, info, log, rpr, warn, whisper, ƒ;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '﴾4-number﴿';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  ƒ = require('flowmatic');

  this.options = {
    'digits': /[0-9]+/
  };

  this.constructor = function(G, $) {
    G.digits = function() {
      return (ƒ.or(function() {
        return ƒ.regex($['digits']);
      })).onMatch(function(match) {
        return match[0];
      });
    };
    G.integer = function() {
      return (ƒ.or(function() {
        return G.digits;
      })).onMatch(function(match, state) {
        return G.nodes.integer(state, match, parseInt(match, 10));
      }).describe('NUMBER/integer');
    };
    G.integer.as = {
      coffee: function(node) {
        var value;
        value = node.value;
        return {
          target: rpr(node['value'])
        };
      }
    };
    G.literal = function() {
      return ƒ.or((function() {
        return G.integer;
      }));
    };
    G.nodes.integer = function(state, raw, value) {
      return ƒ["new"]._XXX_YYY_node(G.integer.as, state, 'NUMBER/integer', {
        'raw': raw,
        'value': value
      });
    };
    G.tests['digits: parses sequences of ASCII digits'] = function(test) {
      var probe, _i, _len, _ref, _results;
      _ref = "0 12 7 1928374 080".split(/\s+/);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        probe = _ref[_i];
        _results.push(test.eq(G.digits.run(probe), probe));
      }
      return _results;
    };
    G.tests['digits: does not parse sequences with non-digits (1)'] = function(test) {
      var probe, _i, _len, _ref, _results;
      _ref = "0x 1q2 7# 192+8374 08.0".split(/\s+/);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        probe = _ref[_i];
        _results.push(test.throws(((function(_this) {
          return function() {
            return G.digits.run(probe);
          };
        })(this)), /Expected end/));
      }
      return _results;
    };
    G.tests['digits: does not parse sequences with non-digits (2)'] = function(test) {
      var probe, _i, _len, _ref, _results;
      _ref = "q192 +3 -42".split(/\s+/);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        probe = _ref[_i];
        _results.push(test.throws(((function(_this) {
          return function() {
            return G.digits.run(probe);
          };
        })(this)), /Expected \/\[0-9\]\+\//));
      }
      return _results;
    };
    G.tests['integer: parses sequences of ASCII digits'] = function(test) {
      var probe, _i, _len, _ref, _results;
      _ref = "0 12 7 1928374 080".split(/\s+/);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        probe = _ref[_i];
        _results.push(test.eq(G.integer.run(probe), G.nodes.integer(null, probe, parseInt(probe, 10))));
      }
      return _results;
    };
    G.tests['number: recognizes integers'] = function(test) {
      var probe, _i, _len, _ref, _results;
      _ref = "0 12 7 1928374 080".split(/\s+/);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        probe = _ref[_i];
        _results.push(test.eq(G.literal.run(probe), G.nodes.integer(null, probe, parseInt(probe, 10))));
      }
      return _results;
    };
    return G.tests['number: compiles integers to JS'] = function(test) {
      var matcher, node, probe, probes_and_matchers, result, translation, _i, _len, _ref, _results;
      probes_and_matchers = [['0', '0'], ['000', '0'], ['123', '123'], ['00000123', '123'], ['123456789123456789123456789', '1.2345678912345679e+26']];
      _results = [];
      for (_i = 0, _len = probes_and_matchers.length; _i < _len; _i++) {
        _ref = probes_and_matchers[_i], probe = _ref[0], matcher = _ref[1];
        node = G.literal.run(probe);
        translation = G.integer.as.coffee(node);
        result = ƒ.as.coffee.target(translation);
        _results.push(test.eq(result, matcher));
      }
      return _results;
    };
  };

  ƒ["new"].consolidate(this);

}).call(this);

// Generated by CoffeeScript 1.7.1

/* Parses nested structures.
* **meta-characters** (opener, connector, closer);
* **material characters** are code points that are not meta-characters;
* **phrase**: a contiguous sequence of material characters;
* **suite**: a contiguous sequence of phrases;
* **stage**: suites with a common parent; may include nested stages
* **module**: the outermost stage of a given source.

 * * **chunk**
 * * **block**
 */

(function() {
  var $new, BNP, TRM, TYPES, XRE, alert, badge, debug, echo, help, info, log, rainbow, rpr, warn, whisper, ƒ,
    __slice = [].slice;

  TRM = require('coffeenode-trm');

  TYPES = require('coffeenode-types');

  rpr = TRM.rpr.bind(TRM);

  badge = '﴾7-indentation﴿';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  rainbow = TRM.rainbow.bind(TRM);

  BNP = require('coffeenode-bitsnpieces');

  ƒ = require('flowmatic');

  $new = ƒ["new"];

  XRE = require('./9-xre');

  this.$ = {
    'opener': '⟦',
    'connector': '∿',
    'closer': '⟧',

    /* When `true`, suites are single strings that represent lines separated by `connector`; when `false`,
    suites are lists with lines as elements:
     */
    'join-suites': false
  };

  this.$new = $new["new"](this);

  this.$new.$suite = function(G, $) {
    var R, metachrs;
    metachrs = XRE.$esc($['opener'] + $['closer']);
    R = ƒ.repeatSeparated(RegExp("[^" + metachrs + "]+"), $['connector']);
    R = R.onMatch(function(match) {
      return match.join($['connector']);
    });
    return R;
  };

  this.$new.$stage = function(G, $) {
    var R;
    R = ƒ.seq($['opener'], (function() {
      return G.$chunks;
    }), $['closer']);
    R = R.onMatch(function(match) {
      return match[1];
    });
    return R;
  };

  this.$new.$chunk = function(G, $) {
    var R;
    R = ƒ.or((function() {
      return G.$suite;
    }), (function() {
      return G.$stage;
    }));
    return R;
  };

  this.$new.$chunks = function(G, $) {
    var R;
    R = ƒ.repeat((function() {
      return G.$chunk;
    }), 1);
    R = R.onMatch(function(match) {
      var RR, element, _i, _len;
      if ($['join-suites']) {
        return match;
      }
      RR = [];
      for (_i = 0, _len = match.length; _i < _len; _i++) {
        element = match[_i];
        if (TYPES.isa_text(element)) {
          RR.splice.apply(RR, [RR.length, 0].concat(__slice.call(element.split($['connector']))));
        } else {
          RR.push(element);
        }
      }
      return RR;
    });
    return R;
  };

  this.$new.$module = function(G, $) {
    var R;
    R = ƒ.seq((function() {
      return G.$chunk;
    }), ƒ.end);
    R = R.onMatch(function(match) {
      return match[0];
    });
    return R;
  };


  /* Run `@$new` to make `@` (`this`) an instance of this grammar with default options: */

  this.$new(this, null);

  this.$TESTS = {
    '$suite: parses phrases joined by connector (1)': function(test) {
      var G, source;
      G = this.$new({
        opener: '<',
        connector: '=',
        closer: '>',
        'join-suites': false
      });
      source = 'abc=def=ghi';
      return test.eq(G.$suite.run(source), 'abc=def=ghi');
    },
    '$suite: parses phrases joined by connector (2)': function(test) {
      var G, source;
      G = this.$new({
        opener: '<',
        connector: '=',
        closer: '>',
        'join-suites': true
      });
      source = 'abc=def=ghi';
      return test.eq(G.$suite.run(source), 'abc=def=ghi');
    },
    '$chunk: parses simple bracketed expression (1)': function(test) {
      var G, source;
      G = this.$new({
        opener: '<',
        connector: '=',
        closer: '>',
        'join-suites': false
      });
      source = '<abc=def=ghi>';
      return test.eq(G.$chunk.run(source), ['abc', 'def', 'ghi']);
    },
    '$chunk: parses simple bracketed expression (2)': function(test) {
      var G, source;
      G = this.$new({
        opener: '<',
        connector: '=',
        closer: '>',
        'join-suites': true
      });
      source = '<abc=def=ghi>';
      debug(G.$chunk.run(source));
      return test.eq(G.$chunk.run(source), ['abc=def=ghi']);
    },
    '$chunk: parses nested bracketed expression (1)': function(test) {
      var G, source;
      G = this.$new({
        opener: '<',
        connector: '=',
        closer: '>',
        'join-suites': false
      });
      source = '<abc=def<ghi<jkl=mno>>pqr>';
      return test.eq(G.$chunk.run(source), ['abc', 'def', ['ghi', ['jkl', 'mno']], 'pqr']);
    },
    '$chunk: parses nested bracketed expression (2)': function(test) {
      var G, source;
      G = this.$new({
        opener: '<',
        connector: '=',
        closer: '>',
        'join-suites': true
      });
      source = '<abc=def<ghi<jkl=mno>>pqr>';
      return test.eq(G.$chunk.run(source), ['abc=def', ['ghi', ['jkl=mno']], 'pqr']);
    },
    '$module: parses nested bracketed expression (1)': function(test) {
      var G, source;
      G = this.$new({
        opener: '<',
        connector: '=',
        closer: '>',
        'join-suites': false
      });
      source = '<abc=def<ghi<jkl=mno>>pqr>';
      return test.eq(G.$module.run(source), ['abc', 'def', ['ghi', ['jkl', 'mno']], 'pqr']);
    },
    '$module: parses nested bracketed expression (2)': function(test) {
      var G, source;
      G = this.$new({
        opener: '<',
        connector: '=',
        closer: '>',
        'join-suites': true
      });
      source = '<abc=def<ghi<jkl=mno>>pqr>';
      return test.eq(G.$module.run(source), ['abc=def', ['ghi', ['jkl=mno']], 'pqr']);
    }
  };

}).call(this);

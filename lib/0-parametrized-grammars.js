// Generated by CoffeeScript 1.6.3

/*

 * Demo: Parametrized Grammars

 *# Rationale

In this module, we want to explore how to parametrize grammars.

Let's say you've found a grammar `G` that parses nested lists, as in `[ 1, [ 2, 3, [ 4 ], 5 ]]`. Obviously,
if the grammar works for square brackets, it should not only work for pointy brackets, too, and for any pair
of distinct characters `( o, c )`. Likewise, the mark that separates elements could conceivably any old
character, as long as it fits into the general setup of the rest of the language. Finally, what is allowed
to appear as e single element in such a construct is a 'little language' (a grammar, a rule) in its own
right—it's easy to see that if this version works for list literals à la what's sketched aboved, it can,
mutatis mutandis, also serve to parse set literals like `{ 1, { 2, 3, { 4 }, 5 }}` and POD literals like
`{ a: 1, { b: 2, c: 3, { d: 4 }, e: 5 }}`.

 *# Naming Conventions

In non-parametrized ('direct', or 'constant') grammars, you bind all your rules to `@` (`this`) on the
module level. You should start all rules that are part of the grammar proper (i.e. those that produce
use the Arabika `new` module to produce AST nodes that are in line with the
[SpiderMonkey Parser API](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API))
with a lower case Latin letter (although nothing keeps you from using other scripts if you feel like it).

Grammar rules should generally be kept as short as possible—typically, they're one-liners (plus an
`.onMatch()` handler, also often on a single line). This is mainly because the `packrattle` parser is wont
to throw hard-to-interpret error messages that do not include references to the source code line that caused
the trouble; it is therefore of paramount importance to break down the parsing process into many small
pieces with focussed concerns, each of which should be individually tested in the `$TESTS` section (see
below); that way, it's easier to narrow down faulty grammar rules.

As a side effect of working with *lots* of very simple rules, it's not always convenient to have all rules
produce full-blown SM Parser API nodes; often, a simple list or a string is all the result you need. Also,
helper functions, options objects and data collections are sometimes needed to sort things out in an
organized fashion. To help consumers identify exactly which rules produce Parser API nodes, the convention
is to give all such methods names that start with a lower case Latin letter; all methods and other objects
that serve other purposes should start with a `$` (dollar sign).
 */

(function() {
  var NEW, TRM, XRE, alert, badge, debug, echo, help, info, log, rainbow, rpr, warn, whisper, π,
    __slice = [].slice;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '﴾0-parametrized-grammars﴿';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  rainbow = TRM.rainbow.bind(TRM);

  π = require('coffeenode-packrattle');

  NEW = require('./NEW');

  XRE = require('./9-xre');


  /* */

  this.$ = {
    'opener': '⟦',
    'connector': '∿',
    'closer': '⟧'
  };


  /* TAINT move to NEW */

  this.$new = function(options, target) {
    var R, get_rule, name, rule_name, value, _ref, _ref1;
    if (options == null) {
      options = {};
    }
    _ref = this.$;
    for (name in _ref) {
      value = _ref[name];
      if (options[name] == null) {
        options[name] = value;
      }
    }
    R = target != null ? target : {};
    R['$'] = options;
    R['$new'] = this.$new;
    _ref1 = this.$new;
    for (rule_name in _ref1) {
      get_rule = _ref1[rule_name];
      R[rule_name] = get_rule(R, options);
    }
    return R;
  };

  this.$new.bracketed = function(G, $) {
    var R;
    R = π.seq($['opener'], π.repeat((function(_this) {
      return function() {
        return G.expression;
      };
    })(this)), $['closer']);
    R.onMatch(function(match) {
      return ['bracketed', match[0], match[1], match[2]];
    });
    return R;
  };

  this.$new.phrases = function(G, $) {
    var R;
    R = π.repeatSeparated(G.phrase, RegExp("" + (XRE.$_esc($['connector']))));
    R.onMatch(function(match) {
      return ['phrases'].concat(__slice.call(match));
    });
    return R;
  };

  this.$new.phrase = function(G, $) {
    var R, metachrs;
    metachrs = XRE.$_esc($['opener'] + $['connector'] + $['closer']);
    R = π.regex(RegExp("[^" + metachrs + "]+"));
    R.onMatch(function(match) {
      return ['phrase', match[0]];
    });
    return R;
  };

  this.$new.expression = function(G, $) {
    return π.alt(G.bracketed, G.phrases);
  };

  this.$new(null, this);

  this.$TESTS = {
    'bracketed: parses simple bracketed phrase': function(test) {
      var G, source;
      G = this.$new({
        opener: '(',
        connector: '|',
        closer: ')'
      });
      source = "(xxx)";
      return test.eq(G.bracketed.run(source), ["bracketed", "(", [["phrases", ["phrase", "xxx"]]], ")"]);
    }
  };

  this._ = function() {
    var njs_fs, parse_info, write;
    njs_fs = require('fs');
    write = function(route, content) {
      return njs_fs.writeFileSync(route, content);
    };
    parse_info = π.parse(this.expression, source, {
      debugGraph: true
    });
    if (parse_info['ok']) {
      return info(parse_info['match']);
    } else {
      warn(parse_info['message'] + '\n' + parse_info['state'].toSquiggles().join('\n'));
      return write("/tmp/process.dot", parse_info['state'].debugGraphToDot());
    }
  };

  this._write_graphs = function() {
    var grammar, name, njs_fs, write, _i, _len, _ref, _results;
    njs_fs = require('fs');
    write = function(route, content) {
      return njs_fs.writeFileSync(route, content);
    };
    _ref = 'expression phrase bracketed'.split(/\s+/);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      name = _ref[_i];
      grammar = this[name];
      _results.push(write("/tmp/" + name + ".dot", grammar.toDot()));
    }
    return _results;
  };

  if (module.parent == null) {
    this._();
    this._write_graphs();
  }

}).call(this);

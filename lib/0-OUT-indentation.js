// Generated by CoffeeScript 1.6.3
(function() {
  var $new, BNP, TRM, alert, badge, debug, echo, help, info, log, rainbow, rpr, warn, whisper, π,
    __slice = [].slice;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '﴾7-indentation﴿';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  rainbow = TRM.rainbow.bind(TRM);

  π = require('coffeenode-packrattle');

  BNP = require('coffeenode-bitsnpieces');

  $new = require('./NEW');


  /* Parses nested structures.
  * **meta-characters** are `<`, `=`, `>` (easy to type, not special in RegExes);
  * **material characters** are code points that are not meta-characters;
  * **phrase**: a contiguous sequence of material characters;
  * **suite**: a contiguous sequence of phrases;
  * **stage**: suites with a common parent; may include nested stages
  * **module**: the outermost stage of a given source.
  
   * * **chunk**
   * * **block**
  
  Valid inputs include:
  
  ````
  <>
  <1>
  <1 = 2>
  <1 = 2 <3>>
  <1 = 2 <3 <4>>
  <1 = 2 <3 <4 = 5>>
  <1 = 2 <3 <4 = 5> 6>
  <1 = 2 <3 <4 = 5> 6 = 7>
  ````
   */

  this.$new = $new["new"](this);

  this.$new.$phrase = function(G, $) {
    var R;
    R = π.alt(/[^<=>]+/);
    R = R.onMatch(function(match) {
      return match[0];
    });
    return R;
  };

  this.$new.$suite = function(G, $) {
    var R;
    R = π.repeatSeparated((function() {
      return G.$phrase;
    }), /=/);
    R = R.onMatch(function(match) {
      return ['suite'].concat(__slice.call(match));
    });
    return R;
  };

  this.$new.$chunk = function(G, $) {
    var R;
    R = π.alt((function() {
      return G.$suite;
    }), (function() {
      return G.$stage;
    }));
    R = R.onMatch(function(match) {
      return ['chunk'].concat(__slice.call(match));
    });
    return R;
  };

  this.$new.$chunks = function(G, $) {
    var R;
    R = π.repeat((function() {
      return G.$chunk;
    }), 1);
    R = R.onMatch(function(match) {
      return ['chunks'].concat(__slice.call(match));
    });
    return R;
  };

  this.$new.$stage = function(G, $) {
    var R;
    R = π.seq(/</, (function() {
      return G.$chunks;
    }), />/);
    R = R.onMatch(function(match) {
      return ['stage'].concat(__slice.call(match));
    });
    return R;
  };


  /* Run `@$new` to make `@` (`this`) an instance of this grammar with default options: */

  this.$new(this, null);

  this.$TESTS = {
    '$phrase: parses source without meta-characters': function(test) {
      return null;
    }
  };

}).call(this);

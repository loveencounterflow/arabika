// Generated by CoffeeScript 1.6.3
(function() {
  var BNP, NEW, TRM, XRE, XRegExp, alert, badge, debug, echo, extension_u, help, info, log, rainbow, rpr, warn, whisper, π,
    __slice = [].slice;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '﴾9-xre﴿';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  rainbow = TRM.rainbow.bind(TRM);

  π = require('coffeenode-packrattle');

  BNP = require('coffeenode-bitsnpieces');

  NEW = require('./NEW');


  /* See:
    https://github.com/loveencounterflow/xregexp3
    https://github.com/slevithan/xregexp/wiki/Roadmap
    https://gist.github.com/slevithan/2630353
    http://blog.stevenlevithan.com/archives/javascript-regex-and-unicode
   */

  XRegExp = require('xregexp3');


  /* Always allow expressions like `\p{...}` to match beyond the Unicode BMP: */

  XRegExp.install('astral');


  /* Always allow new extensions: */

  XRegExp.install('extensibility');

  extension_u = {
    matcher: /\\u{([0-9A-Fa-f]{1,6})}/,
    handler: (function() {
      var dec, hex, pad4;
      pad4 = function(s) {
        while (s.length < 4) {
          s = "0" + s;
        }
        return s;
      };
      dec = function(hex) {
        return parseInt(hex, 16);
      };
      hex = function(dec) {
        return parseInt(dec, 10).toString(16);
      };
      return function(match) {
        var code, offset;
        code = dec(match[1]);
        offset = void 0;
        if (code > 0x10FFFF) {
          throw new SyntaxError("invalid Unicode code point " + match[0]);
        }
        if (code <= 0xFFFF) {
          return "\\u" + pad4(hex(code));
        }
        offset = code - 0x10000;
        return "\\u" + pad4(hex(0xD800 + (offset >> 10))) + "\\u" + pad4(hex(0xDC00 + (offset & 0x3FF)));
      };
    })(),
    options: {
      scope: 'all'
    }
  };

  XRegExp.addToken(extension_u.matcher, extension_u.handler, extension_u.options);


  /* Add the Q flag that makes the dot match all code units */

  XRegExp.addToken(/\./, function(match, scope, flags) {
    var dot;
    dot = /s/.test(flags) ? '[\\s\\S]' : '.';
    return "(?:[\\ud800-\\udbff][\\udc00-\\udfff]|" + dot + ")";
  }, {
    scope: 'default',
    flag: 'Q'
  });


  /* Add the U (ungreedy) flag from PCRE and RE2, which reverses greedy and lazy quantifiers: */

  XRegExp.addToken(/([?*+]|{\d+(?:,\d*)?})(\??)/, function(match) {
    return match[1] + (match[2] ? '' : '?');
  }, {
    flag: 'U'
  });

  module.exports = XRE = function() {
    var P;
    P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return XRegExp.apply(null, P);
  };

  XRE.$_esc = BNP.escape_regex.bind(BNP);

  XRE.TESTS = {
    '(all): even without flag `A`, `\\p{}` expressions match astral characters': function(test) {
      var matcher;
      matcher = XRegExp('\\pL');
      return test.eq(('〇𠀝x'.match(matcher))[0], '𠀝');
    },
    '(all): even without flag `u`, `\\u{}` expressions match (astral) characters by codepoint': function(test) {
      test.eq(('〇𠀝x'.match(XRegExp('\\u{3007}')))[0], '〇');
      return test.eq(('〇𠀝x'.match(XRegExp('\\u{2001d}')))[0], '𠀝');
    },
    '(`Q` flag): make dot match code points (instead of code units)': function(test) {
      return test.eq(('𠀝x'.match(XRegExp('.', 'Q')))[0], '𠀝');
    },
    '(`Q` flag): dot matches code units without flag': function(test) {
      return test.eq(('𠀝x'.match(XRegExp('.')))[0], '\ud840');
    },
    '(`Q` flag): respects `s` flag': function(test) {
      test.eq(('𠀁x\nabc'.match(XRegExp('.+')))[0], '𠀁x');
      test.eq(('𠀁x\nabc'.match(XRegExp('.+', 'Q')))[0], '𠀁x');
      test.eq(('𠀁x\nabc'.match(XRegExp('.+', 'Qs')))[0], '𠀁x\nabc');
      return test.eq(('𠀁x\nabc'.match(XRegExp('.+', 's')))[0], '𠀁x\nabc');
    }
  };

}).call(this);

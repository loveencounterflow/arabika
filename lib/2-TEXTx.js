// Generated by CoffeeScript 1.7.1
(function() {
  var $new, BNP, CHR, TRM, XRE, alert, badge, debug, echo, help, info, log, rainbow, rpr, warn, whisper, ƒ;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '﴾2-text﴿';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  rainbow = TRM.rainbow.bind(TRM);

  BNP = require('coffeenode-bitsnpieces');

  ƒ = require('flowmatic');

  $new = ƒ["new"];

  CHR = require('./3-chr');

  XRE = require('./XRE');

  this.options = {
    'single-quote': "'",
    'double-quote': '"',
    'chr-escaper': '+',
    'unicode4-metachr': 'u',
    'escape-table': {
      b: '\b',
      f: '\f',
      n: '\n',
      r: '\r',
      t: '\t'
    }
  };

  this.constructor = function(G, $) {

    /* TAINT describe */
    G.$_sq = function() {
      return ƒ.or(function() {
        return ƒ.string($['single-quote']);
      });
    };

    /* TAINT `ƒ.or` is an expedient here */
    G.$_dq = function() {
      return ƒ.or(function() {
        return ƒ.string($['double-quote']);
      });
    };

    /* TAINT escapes on each call; no memoizing */
    G.$_nosq = function() {
      return (ƒ.repeat(function() {
        return ƒ.or((function() {
          return G.$_escaped;
        }), RegExp("[^" + (BNP.escape_regex($['single-quote'])) + "]"));
      })).onMatch(function(match) {
        var submatch;
        return ((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = match.length; _i < _len; _i++) {
            submatch = match[_i];
            _results.push(submatch[0]);
          }
          return _results;
        })()).join('');
      });
    };

    /* TAINT escapes on each call; no memoizing */
    G.$_nodq = function() {
      return (ƒ.repeat(function() {
        return ƒ.or((function() {
          return G.$_escaped;
        }), RegExp("[^" + (BNP.escape_regex($['double-quote'])) + "]"));
      })).onMatch(function(match) {
        var submatch;
        return ((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = match.length; _i < _len; _i++) {
            submatch = match[_i];
            _results.push(submatch[0]);
          }
          return _results;
        })()).join('');
      });
    };

    /* TAINT `ƒ.or` is an expedient here */
    G.$_chr_escaper = function() {
      return ƒ.or(function() {
        return ƒ.string($['chr-escaper']);
      });
    };

    /* TAINT `ƒ.or` is an expedient here */
    G.$_unicode4_metachr = function() {
      return ƒ.or(function() {
        return ƒ.string($['unicode4-metachr']);
      });
    };
    G.$_sq_literal = function() {
      return ƒ.seq(G.$_sq, G.$_nosq, G.$_sq);
    };
    G.$_dq_literal = function() {
      return ƒ.seq(G.$_dq, G.$_nodq, G.$_dq);
    };

    /* TAINT `ƒ.or` is an expedient here */
    G.$_simple_escape = function() {
      return (ƒ.or(function() {
        return ƒ.regex(/[bfnrt]/);
      })).onMatch(function(match) {
        return $['escape-table'][match[0]];
      });
    };

    /* TAINT String conversion method dubious; will fail outside of Unicode BMP */

    /* TAINT use new ES6 String API for codepoints */
    G.$_unicode_hex = function() {
      return (ƒ.seq((function() {
        return G.$_unicode4_metachr;
      }), /[0-9a-fA-F]{4}/)).onMatch(function(match) {
        return String.fromCharCode('0x' + match[1][0]);
      });
    };
    G.$_escaped = function() {
      return (ƒ.seq((function() {
        return G.$_chr_escaper;
      }), ƒ.or((function() {
        return G.$_simple_escape;
      }), (function() {
        return G.$_unicode_hex;
      }), (function() {
        return CHR.$chr;
      })))).onMatch(function(match) {
        return match[1];
      });
    };

    /* TAINT maybe we should *not* un-escape anything; better for translation */
    G.literal = function() {
      return (ƒ.or((function() {
        return G.$_sq_literal;
      }), (function() {
        return G.$_dq_literal;
      }))).onMatch(function(match, state) {
        var ignore, value;
        ignore = match[0], value = match[1], ignore = match[2];
        return G.nodes.literal(state, value);
      });
    };
    G.literal.as = {
      coffee: function(node) {
        var value;
        value = node.value;
        return {
          target: rpr(value)
        };
      }
    };
    G.nodes.literal = function(state, value) {
      return ƒ["new"]._XXX_YYY_node(G.literal.as, state, 'TEXT/literal', {
        'value': value
      });
    };
    G.tests['quotes are single characters'] = function(test) {
      var TYPES;
      TYPES = require('coffeenode-types');
      test.ok(TYPES.isa_text($['single-quote']));
      test.ok(TYPES.isa_text($['double-quote']));
      test.ok($['single-quote'].length === 1);
      return test.ok($['double-quote'].length === 1);
    };
    G.tests['$simple_escape: accepts and translates meta-chracters'] = function(test) {
      var probe, probes_and_matchers, result, _i, _len, _ref, _results;
      probes_and_matchers = [['b', '\b'], ['f', '\f'], ['n', '\n'], ['r', '\r'], ['t', '\t']];
      _results = [];
      for (_i = 0, _len = probes_and_matchers.length; _i < _len; _i++) {
        _ref = probes_and_matchers[_i], probe = _ref[0], result = _ref[1];
        _results.push(test.eq(G.$_simple_escape.run(probe), result));
      }
      return _results;
    };
    G.tests['$escaped: accepts escaped chracters'] = function(test) {
      var escaper, matcher, probe, probes_and_matchers, result, _i, _len, _ref, _results;
      escaper = $['chr-escaper'];
      probes_and_matchers = [["" + escaper + "u4e01", '丁'], ["" + escaper + "b", '\b'], ["" + escaper + "f", '\f'], ["" + escaper + "n", '\n'], ["" + escaper + "r", '\r'], ["" + escaper + "t", '\t']];
      _results = [];
      for (_i = 0, _len = probes_and_matchers.length; _i < _len; _i++) {
        _ref = probes_and_matchers[_i], probe = _ref[0], matcher = _ref[1];
        result = ƒ["new"]._delete_grammar_references(G.$_escaped.run(probe));
        _results.push(test.eq(G.$_escaped.run(probe), matcher));
      }
      return _results;
    };
    G.tests['$nosq: accepts runs of chracters except unescaped single quote'] = function(test) {
      var escaper, probe, probes_and_matchers, result, _i, _len, _ref, _results;
      escaper = $['chr-escaper'];
      probes_and_matchers = [['0', '0'], ['qwertz', 'qwertz'], ["" + escaper + "t", "\t"], ["qw" + escaper + "nertz", "qw\nertz"], ['中華人"民共和國"', '中華人"民共和國"']];
      _results = [];
      for (_i = 0, _len = probes_and_matchers.length; _i < _len; _i++) {
        _ref = probes_and_matchers[_i], probe = _ref[0], result = _ref[1];
        _results.push(test.eq(G.$_nosq.run(probe), result));
      }
      return _results;
    };
    G.tests['$nodq: accepts runs of chracters except unescaped double quote'] = function(test) {
      var probe, probes_and_matchers, result, _i, _len, _ref, _results;
      probes_and_matchers = [['0', '0'], ['qwertz', 'qwertz'], ["中華人'民共和國'", "中華人'民共和國'"]];
      _results = [];
      for (_i = 0, _len = probes_and_matchers.length; _i < _len; _i++) {
        _ref = probes_and_matchers[_i], probe = _ref[0], result = _ref[1];
        _results.push(test.eq(G.$_nodq.run(probe), result));
      }
      return _results;
    };
    G.tests['$literal: accepts single and double quoted string literals'] = function(test) {
      var matcher, probe, probes_and_matchers, result, _i, _len, _ref, _results;
      probes_and_matchers = [
        [
          '"0"', {
            "type": "TEXT/literal",
            "value": "0"
          }
        ], [
          '"qwertz"', {
            "type": "TEXT/literal",
            "value": "qwertz"
          }
        ], [
          "'中華人民共和國'", {
            "type": "TEXT/literal",
            "value": "中華人民共和國"
          }
        ]
      ];
      _results = [];
      for (_i = 0, _len = probes_and_matchers.length; _i < _len; _i++) {
        _ref = probes_and_matchers[_i], probe = _ref[0], matcher = _ref[1];
        result = ƒ["new"]._delete_grammar_references(G.literal.run(probe));
        _results.push(test.eq(result, matcher));
      }
      return _results;
    };
    return G.tests['as.coffee: render text literal as CoffeeScript'] = function(test) {
      var matcher, node, probe, probes_and_matchers, result, translation, _i, _len, _ref, _results;
      probes_and_matchers = [['"0"', "'0'"], ['"qwertz"', "'qwertz'"], ["'中華人民共和國'", "'中華人民共和國'"]];
      _results = [];
      for (_i = 0, _len = probes_and_matchers.length; _i < _len; _i++) {
        _ref = probes_and_matchers[_i], probe = _ref[0], matcher = _ref[1];
        node = G.literal.run(probe);
        translation = G.literal.as.coffee(node);
        result = ƒ.as.coffee.target(translation);
        _results.push(test.eq(result, matcher));
      }
      return _results;
    };
  };

  ƒ["new"].consolidate(this);

}).call(this);

// Generated by CoffeeScript 1.6.3
(function() {
  var BNP, CHR, NAME, NUMBER, TEXT, TRM, alert, badge, debug, echo, help, info, log, rpr, warn, whisper, ƒ;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '﴾10-assignment﴿';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  ƒ = require('flowmatic');

  this.$new = ƒ["new"]["new"](this);

  BNP = require('coffeenode-bitsnpieces');

  TEXT = require('./2-text');

  CHR = require('./3-chr');

  NUMBER = require('./4-number');

  NAME = require('./6-name');

  this.$ = {
    'mark': ':',
    'needs-ilws-before': false,
    'needs-ilws-after': true
  };

  this.$new.expression = function(G, $) {

    /* TAINT placeholder method for a more complete version of what contitutes an expression */
    var R;
    return R = ƒ.or(NUMBER.integer, TEXT.literal, NAME.route);
  };

  this.$new.assignment = function(G, $) {
    var R;
    if ($['needs-ilws-before']) {
      R = ƒ.seq(NAME.route, CHR.ilws, $['mark'], CHR.ilws, (function() {
        return G.expression;
      }));
    } else {
      R = ƒ.seq(NAME.route, $['mark'], CHR.ilws, (function() {
        return G.expression;
      }));
    }
    R = R.onMatch(function(match) {
      var _ref;
      return (_ref = G.new_node).assignment.apply(_ref, match);
    });
    R = R.describe('assignment');
    return R;
  };

  this.$new.assignment.as = function(G, $) {
    return {
      coffee: function(node) {}
    };
  };

  this.$new.new_node = function(G, $) {
    var RR;
    RR = {};
    RR.assignment = function(lhs, mark, rhs) {
      var R;
      R = ƒ["new"]._XXX_node(G, 'Literal', 'assignment');
      R['lhs'] = lhs;
      R['x-mark'] = mark;
      R['rhs'] = rhs;
      return R;
    };
    return RR;
  };

  this.$new.as = function(G, $) {
    var RR;
    RR = {};
    RR.coffee = function(node) {
      var lhs, lhs_result, mark, rhs, rhs_result, subtype, taints, target, type;
      switch (type = node['type']) {
        case 'Literal':
          switch (subtype = node['x-subtype']) {
            case 'assignment':
              lhs = node.lhs, mark = node['x-mark'], rhs = node.rhs;
              lhs_result = ƒ.as.coffee(lhs);
              rhs_result = ƒ.as.coffee(rhs);
              target = "" + lhs_result['target'] + " = " + rhs_result['target'];
              taints = ƒ.as._collect_taints(lhs_result, rhs_result);
              whisper(taints);
              return {
                target: target,
                taints: taints
              };
            default:
              throw new Error("unknown node subtype " + (rpr(subtype)));
          }
          break;
        default:
          throw new Error("unknown node type " + (rpr(type)));
      }
    };

    /* TAINT `standard` is not a good name for this method */
    RR.standard = function(node) {
      var ESPRIMA, source_js;
      ESPRIMA = require('esprima');
      source_js = G.as.js(node);
      return ESPRIMA.parse(source_js);
    };
    return RR;
  };


  /* Run `@$new` to make `@` (`this`) an instance of this grammar with default options: */

  this.$new(this, null);

  this.$TESTS = {
    '$assignment: accepts assignment with name': function(test) {
      var $, G, joiner, matcher, probe, probes_and_matchers, result, _i, _len, _ref, _results;
      G = this;
      $ = G.$;
      joiner = $['crumb/joiner'];
      probes_and_matchers = [
        [
          "abc: 42", {
            "type": "Literal",
            "x-subtype": "assignment",
            "x-mark": ":",
            "lhs": {
              "type": "Literal",
              "x-subtype": "relative-route",
              "raw": "abc",
              "value": [
                {
                  "type": "Identifier",
                  "x-subtype": "identifier-without-sigil",
                  "name": "abc"
                }
              ]
            },
            "rhs": {
              "type": "Literal",
              "x-subtype": "integer",
              "raw": "42",
              "value": 42
            }
          }
        ], [
          "𠀁: '42'", {
            "type": "Literal",
            "x-subtype": "assignment",
            "lhs": {
              "type": "Literal",
              "x-subtype": "relative-route",
              "raw": "𠀁",
              "value": [
                {
                  "type": "Identifier",
                  "x-subtype": "identifier-without-sigil",
                  "name": "𠀁"
                }
              ]
            },
            "x-mark": ":",
            "rhs": {
              "type": "Literal",
              "x-subtype": "text",
              "raw": "'42'",
              "value": "42"
            }
          }
        ]
      ];
      _results = [];
      for (_i = 0, _len = probes_and_matchers.length; _i < _len; _i++) {
        _ref = probes_and_matchers[_i], probe = _ref[0], matcher = _ref[1];
        result = ƒ["new"]._delete_grammar_references(G.assignment.run(probe));
        _results.push(test.eq(result, matcher));
      }
      return _results;
    },
    '$assignment: accepts assignment with route': function(test) {
      var $, G, joiner, matcher, probe, probes_and_matchers, result, _i, _len, _ref, _results;
      G = this;
      $ = G.$;
      joiner = $['crumb/joiner'];
      probes_and_matchers = [
        [
          "yet" + joiner + "another" + joiner + "route: 42", {
            "type": "Literal",
            "x-subtype": "assignment",
            "x-mark": ":",
            "lhs": {
              "type": "Literal",
              "x-subtype": "relative-route",
              "raw": "abc",
              "value": [
                {
                  "type": "Identifier",
                  "x-subtype": "identifier-without-sigil",
                  "name": "abc"
                }
              ]
            },
            "rhs": {
              "type": "Literal",
              "x-subtype": "integer",
              "raw": "42",
              "value": 42
            }
          }
        ], [
          "" + joiner + "chinese" + joiner + "𠀁: '42'", {
            "type": "Literal",
            "x-subtype": "assignment",
            "lhs": {
              "type": "Literal",
              "x-subtype": "relative-route",
              "raw": "𠀁",
              "value": [
                {
                  "type": "Identifier",
                  "x-subtype": "identifier-without-sigil",
                  "name": "𠀁"
                }
              ]
            },
            "x-mark": ":",
            "rhs": {
              "type": "Literal",
              "x-subtype": "text",
              "raw": "'42'",
              "value": "42"
            }
          }
        ]
      ];
      _results = [];
      for (_i = 0, _len = probes_and_matchers.length; _i < _len; _i++) {
        _ref = probes_and_matchers[_i], probe = _ref[0], matcher = _ref[1];
        _results.push(result = ƒ["new"]._delete_grammar_references(G.assignment.run(probe)));
      }
      return _results;
    },
    'as.coffee: render assignment as CoffeeScript': function(test) {
      var $, G, joiner, matcher, node, probe, probes_and_matchers, result, translation, _i, _len, _ref, _results;
      G = this;
      $ = G.$;
      joiner = $['crumb/joiner'];
      probes_and_matchers = [
        [
          "yet/another/route: 42", {
            "type": "Literal",
            "x-subtype": "assignment",
            "x-mark": ":",
            "lhs": {
              "type": "Literal",
              "x-subtype": "relative-route",
              "raw": "abc",
              "value": [
                {
                  "type": "Identifier",
                  "x-subtype": "identifier-without-sigil",
                  "name": "abc"
                }
              ]
            },
            "rhs": {
              "type": "Literal",
              "x-subtype": "integer",
              "raw": "42",
              "value": 42
            }
          }
        ], [
          "/chinese/𠀁: 'some text'", {
            "type": "Literal",
            "x-subtype": "assignment",
            "lhs": {
              "type": "Literal",
              "x-subtype": "relative-route",
              "raw": "𠀁",
              "value": [
                {
                  "type": "Identifier",
                  "x-subtype": "identifier-without-sigil",
                  "name": "𠀁"
                }
              ]
            },
            "x-mark": ":",
            "rhs": {
              "type": "Literal",
              "x-subtype": "text",
              "raw": "'42'",
              "value": "42"
            }
          }
        ]
      ];
      _results = [];
      for (_i = 0, _len = probes_and_matchers.length; _i < _len; _i++) {
        _ref = probes_and_matchers[_i], probe = _ref[0], matcher = _ref[1];
        node = G.assignment.run(probe);
        translation = G.as.coffee(node);
        result = ƒ.as.coffee.target(translation);
        _results.push(debug('\n' + result));
      }
      return _results;
    }
  };

}).call(this);

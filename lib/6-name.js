// Generated by CoffeeScript 1.6.3
(function() {
  var BNP, CHR, TRM, XRE, alert, badge, debug, echo, help, info, log, rpr, show, show_matches, warn, whisper, ƒ;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '﴾3-chr﴿';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  ƒ = require('flowmatic');

  this.$new = ƒ["new"]["new"](this);

  BNP = require('coffeenode-bitsnpieces');

  CHR = require('./3-chr');

  XRE = require('./9-xre');

  show_matches = true;

  show_matches = false;


  /* TAINT this or similar helper to be part of FlowMatic */

  show = function(name, state) {
    if (show_matches) {
      whisper("matching: " + name, rpr(state['internal']['text'].slice(state.pos(), state.endpos())));
    }
    return null;
  };

  this.$ = {

    /* Names: */

    /* Leading and trailing characters in names (excluding sigils): */
    'identifier/first-chr': XRE('\\p{L}'),
    'identifier/trailing-chrs': XRE('(?:-|\\p{L}|\\d)*'),

    /* Character used to form URL-like routes out of crumbs: */
    'crumb/joiner': '/',
    'crumb/this-scope': '.',
    'crumb/parent-scope': '..',

    /* Sigils: */

    /* Sigils may start and classify simple names: */
    'sigils': {
      '~': 'system',
      '.': 'hidden',
      '_': 'private',
      '%': 'cached',
      '!': 'attention'
    },

    /* Marks are like sigils, but with slightly different semantics. */
    'symbol/mark': ':'
  };

  this.$new.$identifier_first_chr = function(G, $) {
    var R;
    R = ƒ.regex($['identifier/first-chr']);
    R = R.onMatch(function(match) {
      return match[0];
    });
    R = R.describe('first character of name');
    return R;
  };

  this.$new.$identifier_trailing_chrs = function(G, $) {
    var R;
    R = ƒ.regex($['identifier/trailing-chrs']);
    R = R.onMatch(function(match) {
      return match[0];
    });
    R = R.describe('trailing characters of name');
    return R;
  };

  this.$new.$sigil = function(G, $) {
    var R, key, sigils;
    sigils = ((function() {
      var _results;
      _results = [];
      for (key in $['sigils']) {
        _results.push(XRE.$esc(key));
      }
      return _results;
    })()).join('');
    R = ƒ.regex(XRE("[" + sigils + "]"));
    R = R.onMatch(function(match, state) {
      return match[0];
    });
    R = R.describe('sigil');
    return R;
  };

  this.$new.identifier_with_sigil = function(G, $) {
    var R;
    R = ƒ.seq(G.$sigil, (function() {
      return G.$identifier_first_chr;
    }), (function() {
      return G.$identifier_trailing_chrs;
    }));
    R = R.onMatch(function(match, state) {
      show('name', state);
      return ƒ["new"].x_identifier_with_sigil(match[0], match[1] + match[2]);
    });
    R = R.describe('identifier-with-sigil');
    return R;
  };

  this.$new.identifier_without_sigil = function(G, $) {
    var R;
    R = ƒ.seq((function() {
      return G.$identifier_first_chr;
    }), (function() {
      return G.$identifier_trailing_chrs;
    }));
    R = R.onMatch(function(match, state) {
      show('$name', state);
      return ƒ["new"].x_identifier_without_sigil(match[0] + match[1]);
    });
    R = R.describe('name-without-sigil');
    return R;
  };

  this.$new.identifier = function(G, $) {
    var R;
    R = ƒ.or((function() {
      return G.identifier_with_sigil;
    }), (function() {
      return G.identifier_without_sigil;
    }));
    R = R.describe('identifier');
    return R;
  };

  this.$new.$crumb = function(G, $) {};

  this.$new.relative_route = function(G, $) {
    var R;
    R = ƒ.repeatSeparated((function() {
      return G.identifier;
    }), $['crumb/joiner']);
    R = R.onMatch(function(match) {
      var identifier, raw;
      raw = ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = match.length; _i < _len; _i++) {
          identifier = match[_i];
          _results.push(identifier['name']);
        }
        return _results;
      })()).join($['crumb/joiner']);
      return ƒ["new"].x_relative_route(raw, match);
    });
    R = R.describe('relative-route');
    return R;
  };

  this.$new.absolute_route = function(G, $) {
    var R;
    R = ƒ.seq($['crumb/joiner'], (function() {
      return G.relative_route;
    }));
    R = R.onMatch(function(match) {
      var route, slash;
      slash = match[0], route = match[1];
      route['raw'] = $['crumb/joiner'] + route['raw'];
      route['x-subtype'] = 'absolute-route';
      return route;
    });
    R = R.describe('absolute-route');
    return R;
  };

  this.$new.route = function(G, $) {
    var R;
    R = ƒ.or((function() {
      return G.absolute_route;
    }), (function() {
      return G.relative_route;
    }));
    R = R.describe('route');
    return R;
  };

  this.$new.symbol = function(G, $) {
    var R;
    R = ƒ.seq($['symbol/mark'], (function() {
      return G.identifier;
    }));
    R = R.onMatch(function(match) {
      var identifier, mark;
      mark = match[0];
      identifier = match[1]['name'];
      return ƒ["new"].x_symbol(mark, mark + identifier, identifier);
    });
    return R;
  };


  /* Run `@$new` to make `@` (`this`) an instance of this grammar with default options: */

  this.$new(this, null);

  this.$TESTS = {
    '$identifier_first_chr: matches first character of names': function(test) {
      var $, G, probe, probes, _i, _len, _results;
      G = this;
      $ = G.$;
      probes = ['a', 'A', '𠀁'];
      _results = [];
      for (_i = 0, _len = probes.length; _i < _len; _i++) {
        probe = probes[_i];
        _results.push(test.eq(G.$identifier_first_chr.run(probe), probe));
      }
      return _results;
    },
    '$identifier_trailing_chrs: matches trailing characters of names': function(test) {
      var $, G, probe, probes, _i, _len, _results;
      G = this;
      $ = G.$;
      probes = ['abc', 'abc-def', 'abc-def-45'];
      _results = [];
      for (_i = 0, _len = probes.length; _i < _len; _i++) {
        probe = probes[_i];
        _results.push(test.eq(G.$identifier_trailing_chrs.run(probe), probe));
      }
      return _results;
    },
    'identifier: matches identifiers': function(test) {
      var $, G, probe, probes_and_results, result, _i, _len, _ref, _results;
      G = this;
      $ = G.$;
      probes_and_results = [
        [
          'n', {
            "type": "Identifier",
            "x-subtype": "identifier-without-sigil",
            "name": "n"
          }
        ], [
          'n0', {
            "type": "Identifier",
            "x-subtype": "identifier-without-sigil",
            "name": "n0"
          }
        ], [
          'readable-names', {
            "type": "Identifier",
            "x-subtype": "identifier-without-sigil",
            "name": "readable-names"
          }
        ], [
          'foo-32', {
            "type": "Identifier",
            "x-subtype": "identifier-without-sigil",
            "name": "foo-32"
          }
        ]
      ];
      _results = [];
      for (_i = 0, _len = probes_and_results.length; _i < _len; _i++) {
        _ref = probes_and_results[_i], probe = _ref[0], result = _ref[1];
        _results.push(test.eq(G.identifier.run(probe), result));
      }
      return _results;
    },
    'identifier: matches identifiers with sigils': function(test) {
      var $, G, probe, probes_and_results, result, _i, _len, _ref, _results;
      G = this;
      $ = G.$;
      probes_and_results = [
        [
          '~n', {
            "type": "Identifier",
            "x-subtype": "identifier-with-sigil",
            "x-sigil": "~",
            "name": "n"
          }
        ], [
          '.n0', {
            "type": "Identifier",
            "x-subtype": "identifier-with-sigil",
            "x-sigil": ".",
            "name": "n0"
          }
        ], [
          '_readable-names', {
            "type": "Identifier",
            "x-subtype": "identifier-with-sigil",
            "x-sigil": "_",
            "name": "readable-names"
          }
        ], [
          '%foo-32', {
            "type": "Identifier",
            "x-subtype": "identifier-with-sigil",
            "x-sigil": "%",
            "name": "foo-32"
          }
        ], [
          '!foo-32', {
            "type": "Identifier",
            "x-subtype": "identifier-with-sigil",
            "x-sigil": "!",
            "name": "foo-32"
          }
        ]
      ];
      _results = [];
      for (_i = 0, _len = probes_and_results.length; _i < _len; _i++) {
        _ref = probes_and_results[_i], probe = _ref[0], result = _ref[1];
        _results.push(test.eq(G.identifier.run(probe), result));
      }
      return _results;
    },
    'identifier: rejects non-identifiers': function(test) {
      var $, G, probe, probes, _i, _len, _results;
      G = this;
      $ = G.$;
      probes = ['034', '-/-', '()', '؟?'];
      _results = [];
      for (_i = 0, _len = probes.length; _i < _len; _i++) {
        probe = probes[_i];
        _results.push(test.throws(((function(_this) {
          return function() {
            return G.identifier.run(probe);
          };
        })(this)), /Expected/));
      }
      return _results;
    },
    '$[ "symbol/mark" ]: is a single character': function(test) {

      /* TAINT test will fail for Unicode 32bit code points */
      var $, G, TYPES;
      G = this;
      $ = G.$;
      TYPES = require('coffeenode-types');
      test.ok(TYPES.isa_text($['symbol/mark']));
      return test.ok($['symbol/mark'].length === 1);
    },
    'symbol: accepts sequences of symbol/mark, name chrs': function(test) {
      var $, G, mark, probe, probes_and_results, result, _i, _len, _ref, _results;
      G = this;
      $ = G.$;
      mark = this.$['symbol/mark'];
      probes_and_results = [
        [
          "" + mark + "x", {
            "type": "Literal",
            "x-subtype": "symbol",
            "x-mark": ":",
            "raw": ":x",
            "value": "x"
          }
        ], [
          "" + mark + "foo", {
            "type": "Literal",
            "x-subtype": "symbol",
            "x-mark": ":",
            "raw": ":foo",
            "value": "foo"
          }
        ], [
          "" + mark + "Supercalifragilisticexpialidocious", {
            "type": "Literal",
            "x-subtype": "symbol",
            "x-mark": ":",
            "raw": ":Supercalifragilisticexpialidocious",
            "value": "Supercalifragilisticexpialidocious"
          }
        ]
      ];
      _results = [];
      for (_i = 0, _len = probes_and_results.length; _i < _len; _i++) {
        _ref = probes_and_results[_i], probe = _ref[0], result = _ref[1];
        _results.push(test.eq(G.symbol.run(probe), result));
      }
      return _results;
    },
    'symbol: rejects names with whitespace': function(test) {
      var $, G, mark, probe, probes, _i, _len, _results;
      G = this;
      $ = G.$;
      mark = this.$['symbol/mark'];
      probes = ["" + mark + "xxx xxx", "" + mark + "foo\tbar", "" + mark + "Super/cali/fragilistic/expialidocious"];
      _results = [];
      for (_i = 0, _len = probes.length; _i < _len; _i++) {
        probe = probes[_i];
        _results.push(test.throws((function() {
          return G.symbol.run(probe);
        }), /Expected/));
      }
      return _results;
    },
    'route: accepts crumbs separated by crumb joiners': function(test) {

      /* TAINT test will fail for Unicode 32bit code points */
      var $, G, joiner, probe, probes_and_results, result, _i, _len, _ref, _results;
      G = this;
      $ = G.$;
      joiner = $['crumb/joiner'];
      probes_and_results = [
        [
          "abc" + joiner + "def", {
            "type": "Literal",
            "x-subtype": "relative-route",
            "raw": "abc/def",
            "value": [
              {
                "type": "Identifier",
                "x-subtype": "identifier-without-sigil",
                "name": "abc"
              }, {
                "type": "Identifier",
                "x-subtype": "identifier-without-sigil",
                "name": "def"
              }
            ]
          }
        ], [
          "foo" + joiner + "bar", {
            "type": "Literal",
            "x-subtype": "relative-route",
            "raw": "foo/bar",
            "value": [
              {
                "type": "Identifier",
                "x-subtype": "identifier-without-sigil",
                "name": "foo"
              }, {
                "type": "Identifier",
                "x-subtype": "identifier-without-sigil",
                "name": "bar"
              }
            ]
          }
        ], [
          "Super" + joiner + "cali" + joiner + "fragilistic" + joiner + "expialidocious", {
            "type": "Literal",
            "x-subtype": "relative-route",
            "raw": "Super/cali/fragilistic/expialidocious",
            "value": [
              {
                "type": "Identifier",
                "x-subtype": "identifier-without-sigil",
                "name": "Super"
              }, {
                "type": "Identifier",
                "x-subtype": "identifier-without-sigil",
                "name": "cali"
              }, {
                "type": "Identifier",
                "x-subtype": "identifier-without-sigil",
                "name": "fragilistic"
              }, {
                "type": "Identifier",
                "x-subtype": "identifier-without-sigil",
                "name": "expialidocious"
              }
            ]
          }
        ], [
          "" + joiner + "abc" + joiner + "def", {
            "type": "Literal",
            "x-subtype": "absolute-route",
            "raw": "/abc/def",
            "value": [
              {
                "type": "Identifier",
                "x-subtype": "identifier-without-sigil",
                "name": "abc"
              }, {
                "type": "Identifier",
                "x-subtype": "identifier-without-sigil",
                "name": "def"
              }
            ]
          }
        ]
      ];
      _results = [];
      for (_i = 0, _len = probes_and_results.length; _i < _len; _i++) {
        _ref = probes_and_results[_i], probe = _ref[0], result = _ref[1];
        _results.push(test.eq(G.route.run(probe), result));
      }
      return _results;
    },
    'route: accepts leading slash': function(test) {

      /* TAINT test will fail for Unicode 32bit code points */
      var $, G, joiner, probe, probes_and_results, result, _i, _len, _ref, _results;
      G = this;
      $ = G.$;
      joiner = $['crumb/joiner'];
      probes_and_results = [
        [
          "" + joiner + "abc" + joiner + "def", {
            "type": "Literal",
            "x-subtype": "absolute-route",
            "raw": "/abc/def",
            "value": [
              {
                "type": "Identifier",
                "x-subtype": "identifier-without-sigil",
                "name": "abc"
              }, {
                "type": "Identifier",
                "x-subtype": "identifier-without-sigil",
                "name": "def"
              }
            ]
          }
        ], [
          "" + joiner + "foo" + joiner + "bar", {
            "type": "Literal",
            "x-subtype": "absolute-route",
            "raw": "/foo/bar",
            "value": [
              {
                "type": "Identifier",
                "x-subtype": "identifier-without-sigil",
                "name": "foo"
              }, {
                "type": "Identifier",
                "x-subtype": "identifier-without-sigil",
                "name": "bar"
              }
            ]
          }
        ], [
          "" + joiner + "Super" + joiner + "cali" + joiner + "fragilistic" + joiner + "expialidocious", {
            "type": "Literal",
            "x-subtype": "absolute-route",
            "raw": "/Super/cali/fragilistic/expialidocious",
            "value": [
              {
                "type": "Identifier",
                "x-subtype": "identifier-without-sigil",
                "name": "Super"
              }, {
                "type": "Identifier",
                "x-subtype": "identifier-without-sigil",
                "name": "cali"
              }, {
                "type": "Identifier",
                "x-subtype": "identifier-without-sigil",
                "name": "fragilistic"
              }, {
                "type": "Identifier",
                "x-subtype": "identifier-without-sigil",
                "name": "expialidocious"
              }
            ]
          }
        ], [
          "" + joiner + "abc" + joiner + "def", {
            "type": "Literal",
            "x-subtype": "absolute-route",
            "raw": "/abc/def",
            "value": [
              {
                "type": "Identifier",
                "x-subtype": "identifier-without-sigil",
                "name": "abc"
              }, {
                "type": "Identifier",
                "x-subtype": "identifier-without-sigil",
                "name": "def"
              }
            ]
          }
        ]
      ];
      _results = [];
      for (_i = 0, _len = probes_and_results.length; _i < _len; _i++) {
        _ref = probes_and_results[_i], probe = _ref[0], result = _ref[1];
        _results.push(test.eq(G.route.run(probe), result));
      }
      return _results;
    },
    'route: accepts crumbs with sigils': function(test) {

      /* TAINT test will fail for Unicode 32bit code points */
      var $, G, joiner, probe, probes_and_results, result, _i, _len, _ref, _results;
      G = this;
      $ = G.$;
      joiner = $['crumb/joiner'];
      probes_and_results = [
        [
          "!abc" + joiner + "def", {
            "type": "Literal",
            "x-subtype": "relative-route",
            "raw": "abc/def",
            "value": [
              {
                "type": "Identifier",
                "x-subtype": "identifier-with-sigil",
                "x-sigil": "!",
                "name": "abc"
              }, {
                "type": "Identifier",
                "x-subtype": "identifier-without-sigil",
                "name": "def"
              }
            ]
          }
        ], [
          "foo" + joiner + "%bar", {
            "type": "Literal",
            "x-subtype": "relative-route",
            "raw": "foo/bar",
            "value": [
              {
                "type": "Identifier",
                "x-subtype": "identifier-without-sigil",
                "name": "foo"
              }, {
                "type": "Identifier",
                "x-subtype": "identifier-with-sigil",
                "x-sigil": "%",
                "name": "bar"
              }
            ]
          }
        ], [
          "Super" + joiner + "_cali" + joiner + "fragilistic" + joiner + "expialidocious", {
            "type": "Literal",
            "x-subtype": "relative-route",
            "raw": "Super/cali/fragilistic/expialidocious",
            "value": [
              {
                "type": "Identifier",
                "x-subtype": "identifier-without-sigil",
                "name": "Super"
              }, {
                "type": "Identifier",
                "x-subtype": "identifier-with-sigil",
                "x-sigil": "_",
                "name": "cali"
              }, {
                "type": "Identifier",
                "x-subtype": "identifier-without-sigil",
                "name": "fragilistic"
              }, {
                "type": "Identifier",
                "x-subtype": "identifier-without-sigil",
                "name": "expialidocious"
              }
            ]
          }
        ], [
          "" + joiner + "abc" + joiner + "~def", {
            "type": "Literal",
            "x-subtype": "absolute-route",
            "raw": "/abc/def",
            "value": [
              {
                "type": "Identifier",
                "x-subtype": "identifier-without-sigil",
                "name": "abc"
              }, {
                "type": "Identifier",
                "x-subtype": "identifier-with-sigil",
                "x-sigil": "~",
                "name": "def"
              }
            ]
          }
        ]
      ];
      _results = [];
      for (_i = 0, _len = probes_and_results.length; _i < _len; _i++) {
        _ref = probes_and_results[_i], probe = _ref[0], result = _ref[1];
        _results.push(test.eq(G.route.run(probe), result));
      }
      return _results;
    }
  };

}).call(this);

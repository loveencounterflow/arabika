// Generated by CoffeeScript 1.6.3
(function() {
  var BNP, CHR, TRM, XRE, alert, badge, debug, echo, help, info, log, rpr, warn, whisper, ƒ;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '﴾3-chr﴿';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  ƒ = require('flowmatic');

  this.$new = ƒ["new"]["new"](this);

  BNP = require('coffeenode-bitsnpieces');

  CHR = require('./3-chr');

  XRE = require('./9-xre');

  this.$ = {

    /* Names: */

    /* Leading character in names (excluding sigils): */
    'name-first-chr': XRE('\\p{L}'),

    /* Trailing characters in names: */
    'name-trailing-chrs': XRE('(?:-|\\p{L}|\\d)*'),

    /* Character used to form URL-like routes out of crumbs: */
    'crumbs-joiner': '/',

    /* Sigils may start and classify simple names: */
    'sigils': {
      '@': 'attribute',
      '~': 'system',
      '.': 'hidden',
      '_': 'private',
      '%': 'cached',
      '!': 'attention'
    }
  };

  this.$new.$name_first_chr = function(G, $) {
    var R;
    R = ƒ.regex($['name-first-chr']);
    R = R.onMatch(function(match) {
      return match[0];
    });
    R = R.describe('first character of name');
    return R;
  };

  this.$new.$name_trailing_chrs = function(G, $) {
    var R;
    R = ƒ.regex($['name-trailing-chrs']);
    R = R.onMatch(function(match) {
      return match[0];
    });
    R = R.describe('trailing characters of name');
    return R;
  };

  this.$new.$name_sigil = function(G, $) {
    var R, key, sigils;
    sigils = ((function() {
      var _results;
      _results = [];
      for (key in $['sigils']) {
        _results.push(XRE.$esc(key));
      }
      return _results;
    })()).join('');
    R = ƒ.regex(XRE("[" + sigils + "]"));
    R = R.onMatch(function(match) {
      return match[0];
    });
    R = R.describe('name');
    return R;
  };

  this.$new.$name = function(G, $) {
    var R;
    R = ƒ.seq(ƒ.optional(function() {
      return G.$name_sigil;
    }), (function() {
      return G.$name_first_chr;
    }), (function() {
      return G.$name_trailing_chrs;
    }));
    R = R.onMatch(function(match) {
      return match.join('');
    });
    R = R.describe('name');
    return R;
  };


  /* Run `@$new` to make `@` (`this`) an instance of this grammar with default options: */

  this.$new(this, null);

  this.$TESTS = {
    '$name_first_chr: matches first character of names': function(test) {
      var probe, probes, _i, _len, _results;
      probes = ['a', 'A', '𠀁'];
      _results = [];
      for (_i = 0, _len = probes.length; _i < _len; _i++) {
        probe = probes[_i];
        _results.push(test.eq(this.$name_first_chr.run(probe), probe));
      }
      return _results;
    },
    '$name_trailing_chrs: matches trailing characters of names': function(test) {
      var probe, probes, _i, _len, _results;
      probes = ['abc', 'abc-def', 'abc-def-45'];
      _results = [];
      for (_i = 0, _len = probes.length; _i < _len; _i++) {
        probe = probes[_i];
        _results.push(test.eq(this.$name_trailing_chrs.run(probe), probe));
      }
      return _results;
    },
    '$name: matches names': function(test) {
      var probe, probes, _i, _len, _results;
      probes = ['n', 'n0', 'readable-names', 'foo-32'];
      _results = [];
      for (_i = 0, _len = probes.length; _i < _len; _i++) {
        probe = probes[_i];
        _results.push(test.eq(this.$name.run(probe), probe));
      }
      return _results;
    },
    '$name: matches names with sigils': function(test) {
      var probe, probes, _i, _len, _results;
      probes = ['@n', '%n0', '_readable-names', '.foo-32', '~isa'];
      _results = [];
      for (_i = 0, _len = probes.length; _i < _len; _i++) {
        probe = probes[_i];
        _results.push(test.eq(this.$name.run(probe), probe));
      }
      return _results;
    },
    '$name: rejects non-names': function(test) {
      var probe, probes, _i, _len, _results;
      probes = ['034', '-/-', '()', '؟?'];
      _results = [];
      for (_i = 0, _len = probes.length; _i < _len; _i++) {
        probe = probes[_i];
        _results.push(test.throws(((function(_this) {
          return function() {
            return _this.$name.run(probe);
          };
        })(this)), /Expected/));
      }
      return _results;
    }
  };

}).call(this);

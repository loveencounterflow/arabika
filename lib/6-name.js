// Generated by CoffeeScript 1.6.3
(function() {
  var BNP, CHR, TRM, XRE, alert, badge, debug, echo, help, info, log, rpr, show, show_matches, warn, whisper, ƒ;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '﴾3-chr﴿';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  ƒ = require('flowmatic');

  this.$new = ƒ["new"]["new"](this);

  BNP = require('coffeenode-bitsnpieces');

  CHR = require('./3-chr');

  XRE = require('./9-xre');

  show_matches = false;


  /* TAINT this or similar helper to be part of FlowMatic */

  show = function(name, state) {
    if (show_matches) {
      whisper("matching: " + name, rpr(state['internal']['text'].slice(state.pos(), state.endpos())));
    }
    return null;
  };

  this.$ = {

    /* Names: */

    /* Leading character in names (excluding sigils): */
    'name-first-chr': XRE('\\p{L}'),

    /* Trailing characters in names: */
    'name-trailing-chrs': XRE('(?:-|\\p{L}|\\d)*'),

    /* Character used to form URL-like routes out of crumbs: */
    'crumbs-joiner': '/',

    /* Sigils: */

    /* Sigils may start and classify simple names: */
    'sigils': {
      '@': 'attribute',
      '~': 'system',
      '.': 'hidden',
      '_': 'private',
      '%': 'cached',
      '!': 'attention'
    },

    /* Marks are like sigils, but with slightly different semantics. */
    'symbols-mark': ':'
  };

  this.$new.$name_first_chr = function(G, $) {
    var R;
    R = ƒ.regex($['name-first-chr']);
    R = R.onMatch(function(match) {
      return match[0];
    });
    R = R.describe('first character of name');
    return R;
  };

  this.$new.$name_trailing_chrs = function(G, $) {
    var R;
    R = ƒ.regex($['name-trailing-chrs']);
    R = R.onMatch(function(match) {
      return match[0];
    });
    R = R.describe('trailing characters of name');
    return R;
  };

  this.$new.$sigil = function(G, $) {
    var R, key, sigils;
    sigils = ((function() {
      var _results;
      _results = [];
      for (key in $['sigils']) {
        _results.push(XRE.$esc(key));
      }
      return _results;
    })()).join('');
    R = ƒ.regex(XRE("[" + sigils + "]"));
    R = R.onMatch(function(match, state) {
      show('$sigil', state);
      return match[0];
    });
    R = R.describe('sigil');
    return R;
  };

  this.$new.$name = function(G, $) {
    var R;
    R = ƒ.seq(ƒ.optional(function() {
      return G.$sigil;
    }), (function() {
      return G.$name_first_chr;
    }), (function() {
      return G.$name_trailing_chrs;
    }));
    R = R.onMatch(function(match, state) {
      show('$name', state);
      return ƒ["new"].x_identifier(match[0], match[1]);
    });
    R = R.describe('name');
    return R;
  };

  this.$new.$crumb = function(G, $) {};

  this.$new.$route = function(G, $) {
    var R;
    R = ƒ.repeatSeparated((function() {
      return G.$name;
    }), $['crumbs-joiner']);
    R = R.onMatch(function(match) {
      whisper(match);
      return ƒ["new"].x_route(match.join($['crumbs-joiner']), match);
    });
    R = R.describe('route');
    return R;
  };


  /* TAINT `ƒ.or` is an expedient here */

  this.$new.$symbol = function(G, $) {
    var R;
    R = ƒ.seq($['symbols-mark'], (function() {
      return G.$name;
    }));
    R = R.onMatch(function(match) {
      return ƒ["new"].x_symbol(match.join(''), match[1]);
    });
    return R;
  };


  /* Run `@$new` to make `@` (`this`) an instance of this grammar with default options: */

  this.$new(this, null);

  this.$TESTS = {
    '$name_first_chr: matches first character of names': function(test) {
      var $, G, probe, probes, _i, _len, _results;
      G = this;
      $ = G.$;
      probes = ['a', 'A', '𠀁'];
      _results = [];
      for (_i = 0, _len = probes.length; _i < _len; _i++) {
        probe = probes[_i];
        _results.push(test.eq(G.$name_first_chr.run(probe), probe));
      }
      return _results;
    },
    '$name_trailing_chrs: matches trailing characters of names': function(test) {
      var $, G, probe, probes, _i, _len, _results;
      G = this;
      $ = G.$;
      probes = ['abc', 'abc-def', 'abc-def-45'];
      _results = [];
      for (_i = 0, _len = probes.length; _i < _len; _i++) {
        probe = probes[_i];
        _results.push(test.eq(G.$name_trailing_chrs.run(probe), probe));
      }
      return _results;
    },
    '$name: matches names': function(test) {
      var $, G, probe, probes, _i, _len, _results;
      G = this;
      $ = G.$;
      probes = ['n', 'n0', 'readable-names', 'foo-32'];
      _results = [];
      for (_i = 0, _len = probes.length; _i < _len; _i++) {
        probe = probes[_i];
        _results.push(test.eq(G.$name.run(probe), probe));
      }
      return _results;
    },
    '$name: matches names with sigils': function(test) {
      var $, G, probe, probes, _i, _len, _results;
      G = this;
      $ = G.$;
      probes = ['@n', '%n0', '_readable-names', '.foo-32', '~isa'];
      _results = [];
      for (_i = 0, _len = probes.length; _i < _len; _i++) {
        probe = probes[_i];
        _results.push(test.eq(G.$name.run(probe), probe));
      }
      return _results;
    },
    '$name: rejects non-names': function(test) {
      var $, G, probe, probes, _i, _len, _results;
      G = this;
      $ = G.$;
      probes = ['034', '-/-', '()', '؟?'];
      _results = [];
      for (_i = 0, _len = probes.length; _i < _len; _i++) {
        probe = probes[_i];
        _results.push(test.throws(((function(_this) {
          return function() {
            return G.$name.run(probe);
          };
        })(this)), /Expected/));
      }
      return _results;
    },
    '$[ "symbols-mark" ]: is a single character': function(test) {

      /* TAINT test will fail for Unicode 32bit code points */
      var $, G, TYPES;
      G = this;
      $ = G.$;
      TYPES = require('coffeenode-types');
      test.ok(TYPES.isa_text($['symbols-mark']));
      return test.ok($['symbols-mark'].length === 1);
    },
    '$symbol: accepts sequences of symbols-mark, name chr': function(test) {
      var $, G, mark, probe, probes_and_results, result, _i, _len, _ref, _results;
      G = this;
      $ = G.$;
      mark = this.$['symbols-mark'];
      probes_and_results = [
        [
          "" + mark + "x", {
            "type": "Literal",
            "x-subtype": "symbol",
            "raw": ":x",
            "value": "x"
          }
        ], [
          "" + mark + "foo", {
            "type": "Literal",
            "x-subtype": "symbol",
            "raw": ":foo",
            "value": "foo"
          }
        ], [
          "" + mark + "Supercalifragilisticexpialidocious", {
            "type": "Literal",
            "x-subtype": "symbol",
            "raw": ":Supercalifragilisticexpialidocious",
            "value": "Supercalifragilisticexpialidocious"
          }
        ]
      ];
      _results = [];
      for (_i = 0, _len = probes_and_results.length; _i < _len; _i++) {
        _ref = probes_and_results[_i], probe = _ref[0], result = _ref[1];
        _results.push(test.eq(G.$symbol.run(probe), result));
      }
      return _results;
    },
    '$symbol: rejects names with whitespace': function(test) {
      var $, G, mark, probe, probes, _i, _len, _results;
      G = this;
      $ = G.$;
      mark = this.$['symbols-mark'];
      probes = ["" + mark + "xxx xxx", "" + mark + "foo\tbar", "" + mark + "Super/cali/fragilistic/expialidocious"];
      _results = [];
      for (_i = 0, _len = probes.length; _i < _len; _i++) {
        probe = probes[_i];
        _results.push(test.throws((function() {
          return G.$symbol.run(probe);
        }), /Expected/));
      }
      return _results;
    },
    '$route: accepts single name': function(test) {

      /* TAINT test will fail for Unicode 32bit code points */
      var $, G, probe, probes_and_results, result, _i, _len, _ref, _results;
      G = this;
      $ = G.$;
      probes_and_results = [["abc", ["abc"]], ["國畫很美", ["國畫很美"]]];
      _results = [];
      for (_i = 0, _len = probes_and_results.length; _i < _len; _i++) {
        _ref = probes_and_results[_i], probe = _ref[0], result = _ref[1];
        _results.push(test.eq(G.$route.run(probe), result));
      }
      return _results;
    },
    '$route: accepts crumbs separated by crumb joiners': function(test) {

      /* TAINT test will fail for Unicode 32bit code points */
      var $, G, joiner, probe, probes_and_results, result, _i, _len, _ref, _results;
      G = this;
      $ = G.$;
      joiner = $['crumbs-joiner'];
      probes_and_results = [["abc" + joiner + "def", ["abc", "def"]], ["foo" + joiner + "bar", ["foo", "bar"]], ["Super" + joiner + "cali" + joiner + "fragilistic" + joiner + "expialidocious", ["Super", "cali", "fragilistic", "expialidocious"]], ["" + joiner + "abc" + joiner + "def", ["abc", "def"]]];
      _results = [];
      for (_i = 0, _len = probes_and_results.length; _i < _len; _i++) {
        _ref = probes_and_results[_i], probe = _ref[0], result = _ref[1];
        debug(G.$route.run(probe));
        _results.push(test.eq(G.$route.run(probe), result));
      }
      return _results;
    }
  };

}).call(this);

// Generated by CoffeeScript 1.6.3

/*

Potentially useful character classes:

* from within 7bit US ASCII:
  * any letter;
  * any digit;
  * any punctuation;
  * any single whitespace character;
  * any single linear whitespace character;
  * any single non-whitespace / printing character;
  * space (i.e. U+0020);

* from within 21bit (a.k.a. 32bit) Unicode (v6.3):
  * any single character, be it ASCII, from the Astral Planes, whitespace, newline, whatever;
  * any single non-whitespace / printing character;
  * any digit;
  * any letter;
  * any character except ASCII punctuation;
  * any newline character (zero or more characters that are line endings, including implied EOF);
  * more?
 */

(function() {
  var BNP, NEW, R, TRM, XRE, alert, badge, current_level, d, debug, echo, ending, help, indentation, info, level, line, line_idx, lines, log, material, rainbow, rpr, source, warn, whisper, π, _i, _len;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '﴾8-character﴿';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  rainbow = TRM.rainbow.bind(TRM);

  π = require('coffeenode-packrattle');

  BNP = require('coffeenode-bitsnpieces');

  NEW = require('./NEW');

  XRE = require('./9-xre');

  this.$_constants = {

    /* TAINT dot suspected to match incorrectly? */

    /* TAINT assumes newlines are equal to `\n` */
    'leading-ws': XRE('(?:^|\\n)(\\p{Space_Separator}*)(.*)(?=\\n|$)'),
    'opener': '﴾',
    'closer': '﴿'
  };


  /* TAINT `π.alt` is an expedient here */


  /* TAINT no memoizing */

  this.$_ascii_punctuation = π.alt((function(_this) {
    return function() {
      return π.regex(XRE('[' + (XRE.$_esc(_this.$_constants['ascii-punctuation'])) + ']'));
    };
  })(this));

  this.$_indentation = (π.repeat(XRE('.', 'Qs'))).onMatch(function(match) {
    return match[0];
  });


  /* TAINT `π.alt` is an expedient here */

  this.$_indentation = (π.repeat(' ')).onMatch(function(match) {
    if (match.length / 2 !== parseInt(match.length / 2)) {
      throw new Error("inconsistent indentation");
    }
    return match.join('');
  });

  this.$_indented_material_line = (π.seq(this.$_indentation, /.+/, π.optional('\n'))).onMatch(function(match) {
    return [match[0], match[1][0], match[2]];
  });


  /* TAINT simplified version of LWS */

  this.$_blank_line = (π.regex(/([\x20\t]+)(\n|$)/)).onMatch(function(match) {
    return ['', match[1], match[2]];
  });


  /* TAINT simplified version of LWS */

  this.$_line = π.alt(this.$_blank_line, this.$_indented_material_line);

  this.$_lines = π.repeat(this.$_line);

  this.TESTS = {
    '$...': function(test) {
      return test.fail("no tests");
    }
  };

  d = this.$_constants['leading-ws'];

  debug(''.match(d));

  debug(' '.match(d));

  debug('  '.match(d));

  debug('\n  '.match(d));

  debug('abc'.match(d));

  debug('\n    abc'.match(d));

  debug();

  debug(rpr(''.split(d)));

  debug(rpr(' '.split(d)));

  debug(rpr('  '.split(d)));

  debug(rpr('\n  '.split(d)));

  debug(rpr('abc'.split(d)));

  source = "abc\n  def\n  ghi\n    jkl\n      mno\n    pqr\n  xyz";

  debug(rpr(this.$_indented_material_line.run('  abc')));

  debug(rpr(this.$_indented_material_line.run('  abc\n')));

  lines = this.$_lines.run(source);

  debug(lines);

  R = [];

  current_level = -1;

  for (line_idx = _i = 0, _len = lines.length; _i < _len; line_idx = ++_i) {
    line = lines[line_idx];
    indentation = line[0], material = line[1], ending = line[2];
    level = indentation.length / 2;
    if (level !== parseInt(level)) {
      warn(level, current_level);
      throw new Error("inconsistent indentation (not an even number of spaces) on line #" + (line_idx + 1) + ":\n" + (rpr(line)));
    }
    if (current_level === null) {
      if (level !== 0) {
        warn(level, current_level);
        throw new Error("inconsistent indentation (starts with indentation) on line #" + (line_idx + 1) + ":\n" + (rpr(line)));
      }
    }
    if (level > current_level + 1) {
      warn(level, current_level);
      throw new Error("inconsistent indentation (too deep) on line #" + (line_idx + 1) + ":\n" + (rpr(line)));
    }
    while (level > current_level) {
      current_level += 1;
      R.push(this.$_constants['opener']);
    }
    while (current_level > level) {
      current_level -= 1;
      R.push(this.$_constants['closer']);
    }
    R.push(material);
  }


  /* TAINT code repetition */

  while (current_level > -1) {
    current_level -= 1;
    R.push(this.$_constants['closer']);
  }

  whisper(R);

  info('\n' + R.join('\n'));

}).call(this);

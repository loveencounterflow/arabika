// Generated by CoffeeScript 1.6.3

/*
 */

(function() {
  var $new, CHR, TRM, TYPES, XRE, alert, badge, debug, echo, help, info, log, rainbow, rpr, warn, whisper, π,
    __slice = [].slice;

  TYPES = require('coffeenode-types');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '﴾7-indentation﴿';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  rainbow = TRM.rainbow.bind(TRM);

  π = require('coffeenode-packrattle');

  $new = require('./NEW');

  CHR = require('./3-chr');

  XRE = require('./9-xre');

  this.$ = {

    /* When `true`, suites are single strings that represent lines separated by `connector`; when `false`,
    suites are lists with lines as elements:
     */
    'join-suites': false,
    'opener': '【',
    'connector': '〓',
    'closer': '】',

    /* other popular choices include:
    
     *.........................................................................................................
    'opener':             '↳'
    'connector':          '↦'
    'closer':             '↱'
     *.........................................................................................................
    'opener':             '⇩'
    'connector':          '⇨'
    'closer':             '⇧'
     *.........................................................................................................
    'opener':             '↧'
    'connector':          '↦'
    'closer':             '↥'
     *.........................................................................................................
    'opener':             '￬'
    'connector':          '￫'
    'closer':             '￪'
     *.........................................................................................................
    'opener':             '⟦'
    'connector':          '∿'
    'closer':             '⟧'
     */
    'indentation-chr': ' ',
    'chrs-per-level': 2,

    /* Maximum number of steps that positive indents may progress;
    set to 1 to allow standard single-step indentation (as in Python and CoffeeScript),
    set to e.g. 2 to allow 'unconventional' single and double-step indentation,
    set to Infinity to allow unlimited indentation deltas,
    set to 0 to disallow indentation altogether:
     */
    'delta': 1
  };

  this.$new = $new["new"](this);


  /* TAINT must parameterize */

  this.$new.$_indentation = function(G, $) {
    var R;
    R = π.alt(function() {
      return π.repeat(' ');
    });
    R = R.onMatch(function(match) {
      return match.join('');
    });
    return R;
  };


  /* TAINT naive line ending */

  this.$new.$_raw_indented_material_line = function(G, $) {
    var R;
    R = π.alt(function() {
      return π.seq(G.$_indentation, CHR.$nws, /.*/, π.optional('\n'));
    });
    R = R.onMatch(function(match) {
      var first_chr, indentation, material, nl, rest;
      indentation = match[0], first_chr = match[1], rest = match[2], nl = match[3];
      material = first_chr[0] + rest[0];
      return [indentation, material, nl];
    });
    return R;
  };


  /* TAINT must parameterize */


  /* TAINT naive whitespace definition; use CHR */

  this.$new.$_raw_blank_line = function(G, $) {
    var R;
    R = π.regex(/([\x20\t]+)(\n|$)/);
    R = R.onMatch(function(match) {
      return ['', match[1], match[2]];
    });
    return R;
  };

  this.$new.$_raw_line = function(G, $) {
    return π.alt((function() {
      return G.$_raw_blank_line;
    }), (function() {
      return G.$_raw_indented_material_line;
    }));
  };

  this.$new.$_raw_lines = function(G, $) {
    return π.repeat(function() {
      return G.$_raw_line;
    });
  };


  /* TAINT must escape occurrences of meta-chrs in source */


  /* TAINT should use parser state to indicate error locations */

  this.$new.$_as_bracketed = function(G, $) {
    var R;
    R = function(source) {
      var RR, base_raw_level, chrs_per_level, current_raw_level, delta, dents, ending, indentation, level, line, line_idx, lines, material, max_indent_chrs, raw_level, _i, _len;
      source = source.replace(CHR.$nl_re, '\n');
      if (source[source.length - 1] !== '\n') {
        source += '\n';
      }
      lines = G.$_raw_lines.run(source);
      RR = [];
      chrs_per_level = $['chrs-per-level'];
      delta = $['delta'];
      max_indent_chrs = delta * chrs_per_level;
      base_raw_level = -chrs_per_level;
      current_raw_level = base_raw_level;
      for (line_idx = _i = 0, _len = lines.length; _i < _len; line_idx = ++_i) {
        line = lines[line_idx];
        indentation = line[0], material = line[1], ending = line[2];
        raw_level = indentation.length;
        level = raw_level / chrs_per_level;
        if (raw_level !== Math.floor(raw_level)) {
          throw new Error("inconsistent indentation (no multiple of " + chrs_per_level + " characters) on line #" + (line_idx + 1) + ":\n" + (rpr(line)));
        }
        if (raw_level > current_raw_level + max_indent_chrs) {
          throw new Error("inconsistent indentation (too deep) on line #" + (line_idx + 1) + ":\n" + (rpr(line)));
        }
        if (raw_level > current_raw_level) {
          dents = [];
          while (raw_level > current_raw_level) {
            current_raw_level += chrs_per_level;
            dents.push($['opener']);
          }
          RR.push(dents.join(''));
        } else if (current_raw_level > raw_level) {
          dents = [];
          while (current_raw_level > raw_level) {
            current_raw_level -= chrs_per_level;
            dents.push($['closer']);
          }
          RR.push(dents.join(''));
        } else {
          RR.push($['connector']);
        }
        RR.push(material);
      }

      /* TAINT code repetition */
      if (current_raw_level > base_raw_level) {
        dents = [];
        while (current_raw_level > base_raw_level) {
          current_raw_level -= chrs_per_level;
          dents.push($['closer']);
        }
        RR.push(dents.join(''));
      }
      RR = RR.join('');
      return RR;
    };
    return R;
  };

  this.$new.$suite = function(G, $) {
    var R, metachrs;
    metachrs = XRE.$esc($['opener'] + $['closer']);
    R = π.repeatSeparated(RegExp("[^" + metachrs + "]+"), $['connector']);
    R = R.onMatch(function(match) {
      return match.join($['connector']);
    });
    return R;
  };

  this.$new.$stage = function(G, $) {
    var R;
    R = π.seq($['opener'], (function() {
      return G.$chunks;
    }), $['closer']);
    R = R.onMatch(function(match) {
      return match[1];
    });
    return R;
  };

  this.$new.$chunk = function(G, $) {
    var R;
    R = π.alt((function() {
      return G.$suite;
    }), (function() {
      return G.$stage;
    }));
    return R;
  };

  this.$new.$chunks = function(G, $) {
    var R;
    R = π.repeat((function() {
      return G.$chunk;
    }), 1);
    R = R.onMatch(function(match) {
      var RR, element, _i, _len;
      if ($['join-suites']) {
        return match;
      }
      RR = [];
      for (_i = 0, _len = match.length; _i < _len; _i++) {
        element = match[_i];
        if (TYPES.isa_text(element)) {
          RR.splice.apply(RR, [RR.length, 0].concat(__slice.call(element.split($['connector']))));
        } else {
          RR.push(element);
        }
      }
      return RR;
    });
    return R;
  };

  this.$new.$module = function(G, $) {
    var R;
    R = π.seq((function() {
      return G.$chunk;
    }), π.end);
    R = R.transform(function(text) {
      return G.$_as_bracketed(text);
    });
    R = R.onMatch(function(match) {
      return match[0];
    });
    return R;
  };


  /* Run `@$new` to make `@` (`this`) an instance of this grammar with default options: */

  this.$new(this, null);

  this.$TESTS = {
    '$suite: parses phrases joined by connector (1)': function(test) {
      var G, source;
      G = this.$new({
        opener: '<',
        connector: '=',
        closer: '>',
        'join-suites': false
      });
      source = 'abc=def=ghi';
      return test.eq(G.$suite.run(source), 'abc=def=ghi');
    },
    '$suite: parses phrases joined by connector (2)': function(test) {
      var G, source;
      G = this.$new({
        opener: '<',
        connector: '=',
        closer: '>',
        'join-suites': true
      });
      source = 'abc=def=ghi';
      return test.eq(G.$suite.run(source), 'abc=def=ghi');
    },
    '$chunk: parses simple bracketed expression (1)': function(test) {
      var G, source;
      G = this.$new({
        opener: '<',
        connector: '=',
        closer: '>',
        'join-suites': false
      });
      source = '<abc=def=ghi>';
      return test.eq(G.$chunk.run(source), ['abc', 'def', 'ghi']);
    },
    '$chunk: parses simple bracketed expression (2)': function(test) {
      var G, source;
      G = this.$new({
        opener: '<',
        connector: '=',
        closer: '>',
        'join-suites': true
      });
      source = '<abc=def=ghi>';
      return test.eq(G.$chunk.run(source), ['abc=def=ghi']);
    },
    '$chunk: parses nested bracketed expression (1)': function(test) {
      var G, source;
      G = this.$new({
        opener: '<',
        connector: '=',
        closer: '>',
        'join-suites': false
      });
      source = '<abc=def<ghi<jkl=mno>>pqr>';
      return test.eq(G.$chunk.run(source), ['abc', 'def', ['ghi', ['jkl', 'mno']], 'pqr']);
    },
    '$chunk: parses nested bracketed expression (2)': function(test) {
      var G, source;
      G = this.$new({
        opener: '<',
        connector: '=',
        closer: '>',
        'join-suites': true
      });
      source = '<abc=def<ghi<jkl=mno>>pqr>';
      return test.eq(G.$chunk.run(source), ['abc=def', ['ghi', ['jkl=mno']], 'pqr']);
    },
    '$module: parses indented source (1)': function(test) {
      var G, source;
      G = this.$new({
        opener: '<',
        connector: '=',
        closer: '>',
        'join-suites': false
      });
      source = "abc\ndef\n  ghi\n    jkl\n    mno\npqr";
      return test.eq(G.$module.run(source), ['abc', 'def', ['ghi', ['jkl', 'mno']], 'pqr']);
    },
    '$module: parses indented source (2)': function(test) {
      var G, source;
      G = this.$new({
        opener: '<',
        connector: '=',
        closer: '>',
        'join-suites': true
      });
      source = "abc\ndef\n  ghi\n    jkl\n    mno\npqr";
      return test.eq(G.$module.run(source), ['abc=def', ['ghi', ['jkl=mno']], 'pqr']);
    },
    '$_raw_lines: turns indented source into list of triplets': function(test) {
      var G, lines, source;
      G = this;
      source = "f = ->\n  for x in xs\n    while x > 0\n      x -= 1\n      log x\n      g x\n  log 'ok'\n  log 'over'";
      lines = G.$_raw_lines.run(source);
      return test.eq(lines, [["", "f = ->", "\n"], ["  ", "for x in xs", "\n"], ["    ", "while x > 0", "\n"], ["      ", "x -= 1", "\n"], ["      ", "log x", "\n"], ["      ", "g x", "\n"], ["  ", "log 'ok'", "\n"], ["  ", "log 'over'", ""]]);
    },
    '$_as_bracketed: turns indented source into bracketed string': function(test) {
      var $, G, bracketed, result, source;
      G = this;
      $ = G['$'];
      source = "f = ->\n  for x in xs\n    while x > 0\n      x -= 1\n      log x\n      g x\n  log 'ok'\n  log 'over'";
      bracketed = G.$_as_bracketed(source);
      result = "⟦f = ->⟦for x in xs⟦while x > 0⟦x -= 1∿log x∿g x⟧⟧log 'ok'∿log 'over'⟧⟧";
      result = result.replace(/⟦/g, $['opener']);
      result = result.replace(/⟧/g, $['closer']);
      result = result.replace(/∿/g, $['connector']);
      return test.eq(bracketed, result);
    },
    '$_as_bracketed (default G): disallow unconventional indentation': function(test) {
      var G, source;
      G = this;
      source = "f = ->\n    for x in xs\n  while x > 0\n  log 'ok'\n  log 'over'";
      return test.throws((function() {
        return G.$_as_bracketed(source);
      }), /inconsistent indentation \(too deep\) on line/);
    },
    '$_as_bracketed (custom G): allow unconventional indentation': function(test) {
      var $, G, bracketed, options, result, source;
      options = {
        'delta': Infinity
      };
      G = this.$new(options);
      $ = G['$'];
      source = "f = ->\n    for x in xs\n  while x > 0\n    x -= 1\n    log x\n    g x\n  log 'ok'\n  log 'over'";
      bracketed = G.$_as_bracketed(source);
      result = "⟦f = ->⟦⟦for x in xs⟧while x > 0⟦x -= 1∿log x∿g x⟧log 'ok'∿log 'over'⟧⟧";
      result = result.replace(/⟦/g, $['opener']);
      result = result.replace(/⟧/g, $['closer']);
      result = result.replace(/∿/g, $['connector']);
      return test.eq(bracketed, result);
    },
    '$_as_bracketed (default G): disallow forbidden indentation-like chrs': function(test) {
      var G, source;
      G = this;
      source = "f = ->\n  for x in xs\n    \twhile x > 0\n      x -= 1\n      log x\n      g x\n  log 'ok'\n  log 'over'";
      return test.throws((function() {
        return G.$_as_bracketed(source);
      }), /Expected end/);
    }
  };

}).call(this);

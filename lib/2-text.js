// Generated by CoffeeScript 1.7.1
(function() {
  var $new, BNP, CHR, TRM, XRE, alert, badge, debug, echo, help, info, log, rainbow, rpr, warn, whisper, ƒ;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '﴾2-text﴿';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  rainbow = TRM.rainbow.bind(TRM);

  BNP = require('coffeenode-bitsnpieces');

  ƒ = require('flowmatic');

  $new = ƒ["new"];

  CHR = require('./3-chr');

  XRE = require('./9-xre');

  this.$_constants = {
    'single-quote': "'",
    'double-quote': '"',
    'chr-escaper': '+',
    'unicode4-metachr': 'u',
    'escape-table': {
      b: '\b',
      f: '\f',
      n: '\n',
      r: '\r',
      t: '\t'
    }
  };


  /* TAINT `ƒ.or` is an expedient here */


  /* TAINT describe */

  this.$_sq = ƒ.or((function(_this) {
    return function() {
      return ƒ.string(_this.$_constants['single-quote']);
    };
  })(this));


  /* TAINT `ƒ.or` is an expedient here */

  this.$_dq = ƒ.or((function(_this) {
    return function() {
      return ƒ.string(_this.$_constants['double-quote']);
    };
  })(this));


  /* TAINT escapes on each call; no memoizing */

  this.$_nosq = (ƒ.repeat((function(_this) {
    return function() {
      return ƒ.or((function() {
        return _this.$_escaped;
      }), RegExp("[^" + (BNP.escape_regex(_this.$_constants['single-quote'])) + "]"));
    };
  })(this))).onMatch((function(_this) {
    return function(match) {
      var submatch;
      return ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = match.length; _i < _len; _i++) {
          submatch = match[_i];
          _results.push(submatch[0]);
        }
        return _results;
      })()).join('');
    };
  })(this));


  /* TAINT escapes on each call; no memoizing */

  this.$_nodq = (ƒ.repeat((function(_this) {
    return function() {
      return ƒ.or((function() {
        return _this.$_escaped;
      }), RegExp("[^" + (BNP.escape_regex(_this.$_constants['double-quote'])) + "]"));
    };
  })(this))).onMatch((function(_this) {
    return function(match) {
      var submatch;
      return ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = match.length; _i < _len; _i++) {
          submatch = match[_i];
          _results.push(submatch[0]);
        }
        return _results;
      })()).join('');
    };
  })(this));


  /* TAINT `ƒ.or` is an expedient here */

  this.$_chr_escaper = ƒ.or((function(_this) {
    return function() {
      return ƒ.string(_this.$_constants['chr-escaper']);
    };
  })(this));


  /* TAINT `ƒ.or` is an expedient here */

  this.$_unicode4_metachr = ƒ.or((function(_this) {
    return function() {
      return ƒ.string(_this.$_constants['unicode4-metachr']);
    };
  })(this));

  this.$_sq_literal = ƒ.seq(this.$_sq, this.$_nosq, this.$_sq);

  this.$_dq_literal = ƒ.seq(this.$_dq, this.$_nodq, this.$_dq);


  /* TAINT `ƒ.or` is an expedient here */

  this.$_simple_escape = (ƒ.or((function(_this) {
    return function() {
      return ƒ.regex(/[bfnrt]/);
    };
  })(this))).onMatch((function(_this) {
    return function(match) {
      return _this.$_constants['escape-table'][match[0]];
    };
  })(this));


  /* TAINT String conversion method dubious; will fail outside of Unicode BMP */

  this.$_unicode_hex = (ƒ.seq(((function(_this) {
    return function() {
      return _this.$_unicode4_metachr;
    };
  })(this)), /[0-9a-fA-F]{4}/)).onMatch((function(_this) {
    return function(match) {
      return String.fromCharCode('0x' + match[1]);
    };
  })(this));

  this.$_escaped = (ƒ.seq(((function(_this) {
    return function() {
      return _this.$_chr_escaper;
    };
  })(this)), ƒ.or(((function(_this) {
    return function() {
      return _this.$_simple_escape;
    };
  })(this)), ((function(_this) {
    return function() {
      return _this.$_unicode_hex;
    };
  })(this)), ((function(_this) {
    return function() {
      return CHR.$chr;
    };
  })(this))))).onMatch((function(_this) {
    return function(match) {
      return match[1];
    };
  })(this));


  /* TAINT maybe we should *not* un-escape anything; better for translation */

  this.literal = ƒ.or(((function(_this) {
    return function() {
      return _this.$_sq_literal;
    };
  })(this)), ((function(_this) {
    return function() {
      return _this.$_dq_literal;
    };
  })(this)));

  this.literal = this.literal.onMatch((function(_this) {
    return function(match) {
      var ignore, value;
      ignore = match[0], value = match[1], ignore = match[2];
      return $new.literal('text', match.join(''), value);
    };
  })(this));

  this.$TESTS = {
    'quotes are single characters': function(test) {
      var TYPES;
      TYPES = require('coffeenode-types');
      test.ok(TYPES.isa_text(this.$_constants['single-quote']));
      test.ok(TYPES.isa_text(this.$_constants['double-quote']));
      test.ok(this.$_constants['single-quote'].length === 1);
      return test.ok(this.$_constants['double-quote'].length === 1);
    },
    '$simple_escape: accepts and translates meta-chracters': function(test) {
      var probe, probes_and_matchers, result, _i, _len, _ref, _results;
      probes_and_matchers = [['b', '\b'], ['f', '\f'], ['n', '\n'], ['r', '\r'], ['t', '\t']];
      _results = [];
      for (_i = 0, _len = probes_and_matchers.length; _i < _len; _i++) {
        _ref = probes_and_matchers[_i], probe = _ref[0], result = _ref[1];
        _results.push(test.eq(this.$_simple_escape.run(probe), result));
      }
      return _results;
    },
    '$escaped: accepts escaped chracters': function(test) {
      var escaper, probe, probes_and_matchers, result, _i, _len, _ref, _results;
      escaper = this.$_constants['chr-escaper'];
      probes_and_matchers = [["" + escaper + "u4e01", '丁'], ["" + escaper + "b", '\b'], ["" + escaper + "f", '\f'], ["" + escaper + "n", '\n'], ["" + escaper + "r", '\r'], ["" + escaper + "t", '\t']];
      _results = [];
      for (_i = 0, _len = probes_and_matchers.length; _i < _len; _i++) {
        _ref = probes_and_matchers[_i], probe = _ref[0], result = _ref[1];
        _results.push(test.eq(this.$_escaped.run(probe), result));
      }
      return _results;
    },
    '$nosq: accepts runs of chracters except unescaped single quote': function(test) {
      var escaper, probe, probes_and_matchers, result, _i, _len, _ref, _results;
      escaper = this.$_constants['chr-escaper'];
      probes_and_matchers = [['0', '0'], ['qwertz', 'qwertz'], ["" + escaper + "t", "\t"], ["qw" + escaper + "nertz", "qw\nertz"], ['中華人"民共和國"', '中華人"民共和國"']];
      _results = [];
      for (_i = 0, _len = probes_and_matchers.length; _i < _len; _i++) {
        _ref = probes_and_matchers[_i], probe = _ref[0], result = _ref[1];
        _results.push(test.eq(this.$_nosq.run(probe), result));
      }
      return _results;
    },
    '$nodq: accepts runs of chracters except unescaped double quote': function(test) {
      var probe, probes_and_matchers, result, _i, _len, _ref, _results;
      probes_and_matchers = [['0', '0'], ['qwertz', 'qwertz'], ["中華人'民共和國'", "中華人'民共和國'"]];
      _results = [];
      for (_i = 0, _len = probes_and_matchers.length; _i < _len; _i++) {
        _ref = probes_and_matchers[_i], probe = _ref[0], result = _ref[1];
        _results.push(test.eq(this.$_nodq.run(probe), result));
      }
      return _results;
    },
    '$literal: accepts single and double quoted string literals': function(test) {
      var matcher, probe, probes_and_matchers, result, _i, _len, _ref, _results;
      probes_and_matchers = [
        [
          '"0"', {
            "type": "Literal",
            "x-subtype": "text",
            "raw": "\"0\"",
            "value": "0"
          }
        ], [
          '"qwertz"', {
            "type": "Literal",
            "x-subtype": "text",
            "raw": "\"qwertz\"",
            "value": "qwertz"
          }
        ], [
          "'中華人民共和國'", {
            "type": "Literal",
            "x-subtype": "text",
            "raw": "'中華人民共和國'",
            "value": "中華人民共和國"
          }
        ]
      ];
      _results = [];
      for (_i = 0, _len = probes_and_matchers.length; _i < _len; _i++) {
        _ref = probes_and_matchers[_i], probe = _ref[0], matcher = _ref[1];
        result = this.literal.run(probe);
        _results.push(test.eq(result, matcher));
      }
      return _results;
    }
  };

}).call(this);

// Generated by CoffeeScript 1.6.3
(function() {
  var BNP, CHR, NEW, TRM, XRE, alert, badge, debug, echo, help, info, log, rainbow, rpr, warn, whisper, π;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '﴾2-text﴿';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  rainbow = TRM.rainbow.bind(TRM);

  π = require('coffeenode-packrattle');

  BNP = require('coffeenode-bitsnpieces');

  NEW = require('./NEW');

  CHR = require('./8-character');

  XRE = require('./9-xre');

  this.$_constants = {
    'single-quote': "'",
    'double-quote': '"',
    'chr-escaper': '+',
    'unicode4-metachr': 'u',
    'escape-table': {
      b: '\b',
      f: '\f',
      n: '\n',
      r: '\r',
      t: '\t'
    }
  };


  /* TAINT `π.alt` is an expedient here */

  this.$_sq = π.alt((function(_this) {
    return function() {
      return π.string(_this.$_constants['single-quote']);
    };
  })(this));


  /* TAINT `π.alt` is an expedient here */

  this.$_dq = π.alt((function(_this) {
    return function() {
      return π.string(_this.$_constants['double-quote']);
    };
  })(this));


  /* TAINT escapes on each call; no memoizing */

  this.$_nosq = (π.repeat((function(_this) {
    return function() {
      return π.alt(_this.$_escaped, RegExp("[^" + (BNP.escape_regex(_this.$_constants['single-quote'])) + "]"));
    };
  })(this))).onMatch(function(match) {
    var submatch;
    return ((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = match.length; _i < _len; _i++) {
        submatch = match[_i];
        _results.push(submatch[0]);
      }
      return _results;
    })()).join('');
  });


  /* TAINT escapes on each call; no memoizing */

  this.$_nodq = (π.repeat((function(_this) {
    return function() {
      return π.alt(_this.$_escaped, RegExp("[^" + (BNP.escape_regex(_this.$_constants['double-quote'])) + "]"));
    };
  })(this))).onMatch(function(match) {
    var submatch;
    return ((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = match.length; _i < _len; _i++) {
        submatch = match[_i];
        _results.push(submatch[0]);
      }
      return _results;
    })()).join('');
  });


  /* TAINT `π.alt` is an expedient here */

  this.$_chr_escaper = π.alt((function(_this) {
    return function() {
      return π.string(_this.$_constants['chr-escaper']);
    };
  })(this));


  /* TAINT `π.alt` is an expedient here */

  this.$_unicode4_metachr = π.alt((function(_this) {
    return function() {
      return π.string(_this.$_constants['unicode4-metachr']);
    };
  })(this));

  this.$_sq_literal = π.seq(this.$_sq, this.$_nosq, this.$_sq);

  this.$_dq_literal = π.seq(this.$_dq, this.$_nodq, this.$_dq);


  /* TAINT `π.alt` is an expedient here */

  this.$_simple_escape = (π.alt((function(_this) {
    return function() {
      return π.regex(/[bfnrt]/);
    };
  })(this))).onMatch((function(_this) {
    return function(match) {
      return _this.$_constants['escape-table'][match[0]];
    };
  })(this));


  /* TAINT String conversion method dubious; will fail outside of Unicode BMP */

  this.$_unicode_hex = (π.seq(this.$_unicode4_metachr, /[0-9a-fA-F]{4}/)).onMatch((function(_this) {
    return function(match) {
      return String.fromCharCode('0x' + match[1]);
    };
  })(this));

  this.$_escaped = (π.seq(this.$_chr_escaper, π.alt(this.$_simple_escape, this.$_unicode_hex, this._chr))).onMatch((function(_this) {
    return function(match) {
      return match[1];
    };
  })(this));


  /* TAINT maybe we should *not* un-escape anything; better for translation */

  this.literal = (π.alt(this.$_sq_literal, this.$_dq_literal)).onMatch((function(_this) {
    return function(match) {
      var ignore, value;
      ignore = match[0], value = match[1], ignore = match[2];
      return NEW.literal('text', match.join(''), value);
    };
  })(this));

  this.TESTS = {
    'quotes are single characters': function(test) {
      var TYPES;
      TYPES = require('coffeenode-types');
      test.ok(TYPES.isa_text(this.$_constants['single-quote']));
      test.ok(TYPES.isa_text(this.$_constants['double-quote']));
      test.ok(this.$_constants['single-quote'].length === 1);
      return test.ok(this.$_constants['double-quote'].length === 1);
    },
    '$simple_escape: accepts and translates meta-chracters': function(test) {
      var probe, probes_and_results, result, _i, _len, _ref, _results;
      probes_and_results = [['b', '\b'], ['f', '\f'], ['n', '\n'], ['r', '\r'], ['t', '\t']];
      _results = [];
      for (_i = 0, _len = probes_and_results.length; _i < _len; _i++) {
        _ref = probes_and_results[_i], probe = _ref[0], result = _ref[1];
        _results.push(test.eq(this.$_simple_escape.run(probe), result));
      }
      return _results;
    },
    '$escaped: accepts escaped chracters': function(test) {
      var escaper, probe, probes_and_results, result, _i, _len, _ref, _results;
      escaper = this.$_constants['chr-escaper'];
      probes_and_results = [['+u4e01', '丁'], ["" + escaper + "b", '\b'], ["" + escaper + "f", '\f'], ["" + escaper + "n", '\n'], ["" + escaper + "r", '\r'], ["" + escaper + "t", '\t']];
      _results = [];
      for (_i = 0, _len = probes_and_results.length; _i < _len; _i++) {
        _ref = probes_and_results[_i], probe = _ref[0], result = _ref[1];
        _results.push(test.eq(this.$_escaped.run(probe), result));
      }
      return _results;
    },
    '$nosq: accepts runs of chracters except unescaped single quote': function(test) {
      var escaper, probe, probes_and_results, result, _i, _len, _ref, _results;
      escaper = this.$_constants['chr-escaper'];
      probes_and_results = [['0', '0'], ['qwertz', 'qwertz'], ["" + escaper + "t", "\t"], ["qw" + escaper + "nertz", "qw\nertz"], ['中華人"民共和國"', '中華人"民共和國"']];
      _results = [];
      for (_i = 0, _len = probes_and_results.length; _i < _len; _i++) {
        _ref = probes_and_results[_i], probe = _ref[0], result = _ref[1];
        _results.push(test.eq(this.$_nosq.run(probe), result));
      }
      return _results;
    },
    '$nodq: accepts runs of chracters except unescaped double quote': function(test) {
      var probe, probes_and_results, result, _i, _len, _ref, _results;
      probes_and_results = [['0', '0'], ['qwertz', 'qwertz'], ["中華人'民共和國'", "中華人'民共和國'"]];
      _results = [];
      for (_i = 0, _len = probes_and_results.length; _i < _len; _i++) {
        _ref = probes_and_results[_i], probe = _ref[0], result = _ref[1];
        _results.push(test.eq(this.$_nodq.run(probe), result));
      }
      return _results;
    }
  };

}).call(this);

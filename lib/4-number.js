// Generated by CoffeeScript 1.6.3
(function() {
  var NEW, TRM, alert, badge, debug, echo, help, info, log, rpr, warn, whisper, π;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '﴾number﴿';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  π = require('coffeenode-packrattle');

  NEW = require('./NEW');

  this.digits = (π.regex(/[0-9]+/)).onMatch((function(_this) {
    return function(match) {
      return NEW.literal('digits', match[0], match[0]);
    };
  })(this));


  /* TAINT `π.alt` is an expedient here */

  this.integer = (π.alt(this.digits)).onMatch((function(_this) {
    return function(match) {
      match['x-subtype'] = 'integer';
      match['value'] = parseInt(match['raw'], 10);
      return match;
    };
  })(this));

  this.number = π.alt(this.integer);

  this.TESTS = {
    'digits: parses sequences of ASCII digits': function(test) {
      var probe, _i, _len, _ref, _results;
      _ref = "0 12 7 1928374 080".split(/\s+/);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        probe = _ref[_i];
        _results.push(test.eq(this.digits.run(probe), NEW.literal('digits', probe, probe)));
      }
      return _results;
    },
    'digits: does not parse sequences with non-digits (1)': function(test) {
      var probe, _i, _len, _ref, _results;
      _ref = "0x 1q2 7# 192+8374 08.0".split(/\s+/);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        probe = _ref[_i];
        _results.push(test.throws(((function(_this) {
          return function() {
            return _this.digits.run(probe);
          };
        })(this)), /Expected end/));
      }
      return _results;
    },
    'digits: does not parse sequences with non-digits (2)': function(test) {
      var probe, _i, _len, _ref, _results;
      _ref = "q192 +3 -42".split(/\s+/);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        probe = _ref[_i];
        _results.push(test.throws(((function(_this) {
          return function() {
            return _this.digits.run(probe);
          };
        })(this)), /Expected \/\[0-9\]\+\//));
      }
      return _results;
    },
    'integer: parses sequences of ASCII digits': function(test) {
      var probe, _i, _len, _ref, _results;
      _ref = "0 12 7 1928374 080".split(/\s+/);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        probe = _ref[_i];
        _results.push(test.eq(this.integer.run(probe), NEW.literal('integer', probe, parseInt(probe, 10))));
      }
      return _results;
    },
    'number: recognizes integers': function(test) {
      var probe, _i, _len, _ref, _results;
      _ref = "0 12 7 1928374 080".split(/\s+/);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        probe = _ref[_i];
        _results.push(test.eq(this.number.run(probe), NEW.literal('integer', probe, parseInt(probe, 10))));
      }
      return _results;
    },
    'number: compiles integers to JS': function(test) {
      var probe, probes_and_results, result, _i, _len, _ref, _results;
      probes_and_results = [['0', '0'], ['000', '0'], ['123', '123'], ['00000123', '123'], ['123456789123456789123456789', '1.2345678912345679e+26']];
      _results = [];
      for (_i = 0, _len = probes_and_results.length; _i < _len; _i++) {
        _ref = probes_and_results[_i], probe = _ref[0], result = _ref[1];
        _results.push(test.eq(test.as_js(this.number.run(probe)), result));
      }
      return _results;
    }
  };

}).call(this);

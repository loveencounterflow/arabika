// Generated by CoffeeScript 1.6.3
(function() {
  var BNP, ESCODEGEN, LOADER, NEW, TRM, alert, assert, badge, debug, echo, escodegen_options, help, info, log, njs_path, praise, rpr, urge, warn, whisper,
    __slice = [].slice;

  njs_path = require('path');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '﴾test﴿';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  urge = TRM.get_logger('urge', badge);

  praise = TRM.get_logger('praise', badge);

  echo = TRM.echo.bind(TRM);

  NEW = require('./NEW');

  LOADER = require('./grammar-loader');

  assert = require('assert');

  BNP = require('coffeenode-bitsnpieces');

  ESCODEGEN = require('escodegen');

  escodegen_options = (require('../options'))['escodegen'];

  this.test = {
    ok: (function(_this) {
      return function(result) {

        /* `assert.deepEqual` is broken as of https://github.com/joyent/node/issues/7161 */
        if (result !== true) {
          throw new Error("expected true, got\n" + (rpr(result)));
        }
      };
    })(this),
    fail: (function(_this) {
      return function(message) {
        throw new Error(message);
      };
    })(this),
    eq: (function(_this) {
      return function() {
        var P, p;
        P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];

        /* `assert.deepEqual` is broken as of https://github.com/joyent/node/issues/7161 */
        if (!BNP.equals.apply(BNP, P)) {
          throw new Error("not equal: \n" + (((function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = P.length; _i < _len; _i++) {
              p = P[_i];
              _results.push(rpr(p));
            }
            return _results;
          })()).join('\n')));
        }
      };
    })(this),
    as_js: (function(_this) {
      return function(node) {
        return ESCODEGEN.generate(node, escodegen_options);
      };
    })(this),
    throws: assert.throws.bind(assert)
  };

  this.main = function() {
    var TESTS, error, fail_count, locator, miss_count, module, module_name, nr, pass_count, route, route_count, route_info, route_infos, test_count, test_name, _i, _len;
    route_infos = LOADER.get_route_infos({
      all: true
    });
    route_count = route_infos.length;
    test_count = 0;
    pass_count = 0;
    fail_count = 0;
    miss_count = 0;
    for (_i = 0, _len = route_infos.length; _i < _len; _i++) {
      route_info = route_infos[_i];
      route = route_info.route, module_name = route_info.name, nr = route_info.nr;
      info((rpr(nr)) + '-' + module_name);
      module = require(route);
      if ((TESTS = module['$TESTS']) == null) {
        miss_count += 1;
        urge("no tests found for " + nr + "-" + module_name + " (" + route + ")");
        continue;
      }
      for (test_name in TESTS) {
        test_count += 1;
        locator = (rpr(nr)) + '-' + module_name + '/' + test_name;
        try {
          TESTS[test_name].call(module, this.test);
        } catch (_error) {
          error = _error;
          fail_count += 1;
          warn("" + locator + ":");
          warn(error['message']);
          continue;
        }
        pass_count += 1;
        praise("" + locator + ": ok");
      }
    }
    info();
    info("inspected " + route_count + " modules;");
    urge("of these, " + miss_count + " modules had no test cases.");
    whisper("Of " + test_count + " tests,");
    praise("" + pass_count + " tests passed,");
    warn("and " + fail_count + " tests failed.");
    return null;
  };

  if (module.parent == null) {
    this.main();
  }

}).call(this);

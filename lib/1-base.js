// Generated by CoffeeScript 1.7.1
(function() {
  var $new, CHR, NUMBER, ROUTE, TEXT, TRM, XRE, alert, badge, debug, echo, help, info, log, rpr, warn, whisper, ƒ;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '﴾1-base﴿';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  ƒ = require('flowmatic');

  this.$new = ƒ["new"]["new"](this);

  $new = ƒ["new"];

  TEXT = require('./2-text');

  CHR = require('./3-chr');

  NUMBER = require('./4-number');

  ROUTE = require('./6-route');

  XRE = require('./9-xre');

  this.$ = {
    'use-keyword': 'use'
  };


  /* TAINT `ƒ.or` is an expedient here */

  this.$_use_keyword = ƒ.or((function(_this) {
    return function() {
      return ƒ.string(_this.$['use-keyword']);
    };
  })(this));

  this.use_argument = ƒ.or(((function(_this) {
    return function() {
      return ROUTE.symbol;
    };
  })(this)), ((function(_this) {
    return function() {
      return NUMBER.digits;
    };
  })(this)), ((function(_this) {
    return function() {
      return TEXT.literal;
    };
  })(this)));

  this.use_statement = (ƒ.seq(((function(_this) {
    return function() {
      return _this.$_use_keyword;
    };
  })(this)), ((function(_this) {
    return function() {
      return CHR.ilws;
    };
  })(this)), ((function(_this) {
    return function() {
      return _this.use_argument;
    };
  })(this)))).onMatch((function(_this) {
    return function(match) {
      var keyword, raw, value, _ref;
      keyword = match[0], (_ref = match[1], raw = _ref.raw, value = _ref.value);
      return ƒ["new"].x_use_statement(keyword, raw);
    };
  })(this));

  this.$TESTS = {
    'use_argument: accepts symbols': function(test) {
      var $, G, mark, matcher, probe, probes_and_matchers, result, _i, _len, _ref, _results;
      G = this;
      $ = G.$;
      mark = ROUTE.$['symbol/mark'];
      probes_and_matchers = [
        [
          "" + mark + "x", {
            "type": "Literal",
            "x-subtype": "symbol",
            "x-mark": ":",
            "raw": ":x",
            "value": "x"
          }
        ], [
          "" + mark + "foo", {
            "type": "Literal",
            "x-subtype": "symbol",
            "x-mark": ":",
            "raw": ":foo",
            "value": "foo"
          }
        ]
      ];
      _results = [];
      for (_i = 0, _len = probes_and_matchers.length; _i < _len; _i++) {
        _ref = probes_and_matchers[_i], probe = _ref[0], matcher = _ref[1];
        result = ƒ["new"]._delete_grammar_references(G.use_argument.run(probe));
        _results.push(test.eq(result, matcher));
      }
      return _results;
    },
    'use_argument: accepts digits': function(test) {
      var $, G, matcher, probe, probes_and_matchers, result, _i, _len, _ref, _results;
      G = this;
      $ = G.$;
      probes_and_matchers = [["12349876", ƒ["new"].literal('digits', "12349876", "12349876")]];
      _results = [];
      for (_i = 0, _len = probes_and_matchers.length; _i < _len; _i++) {
        _ref = probes_and_matchers[_i], probe = _ref[0], matcher = _ref[1];
        result = ƒ["new"]._delete_grammar_references(G.use_argument.run(probe));
        _results.push(test.eq(result, matcher));
      }
      return _results;
    },
    'use_argument: accepts strings': function(test) {
      var $, G, matcher, probe, probes_and_matchers, result, _i, _len, _ref, _results;
      G = this;
      $ = G.$;
      probes_and_matchers = [["'some text'", ƒ["new"].literal('text', "'some text'", "some text")], ['"other text"', ƒ["new"].literal('text', '"other text"', 'other text')]];
      _results = [];
      for (_i = 0, _len = probes_and_matchers.length; _i < _len; _i++) {
        _ref = probes_and_matchers[_i], probe = _ref[0], matcher = _ref[1];
        result = ƒ["new"]._delete_grammar_references(G.use_argument.run(probe));
        _results.push(test.eq(result, matcher));
      }
      return _results;
    },
    'use_statement: accepts symbols, digits, strings': function(test) {
      var $, G, keyword, mark, matcher, probe, probes_and_matchers, result, _i, _len, _ref, _results;
      G = this;
      $ = G.$;
      mark = ROUTE.$['symbol/mark'];
      keyword = G.$['use-keyword'];
      probes_and_matchers = [["use " + mark + "x", ƒ["new"].x_use_statement(keyword, "" + mark + "x", "x")], ["use " + mark + "foo", ƒ["new"].x_use_statement(keyword, "" + mark + "foo", "foo")], ["use 12349876", ƒ["new"].x_use_statement(keyword, "12349876", "12349876")], ["use 'some text'", ƒ["new"].x_use_statement(keyword, "'some text'", "some text")], ['use "other text"', ƒ["new"].x_use_statement(keyword, '"other text"', 'other text')]];
      _results = [];
      for (_i = 0, _len = probes_and_matchers.length; _i < _len; _i++) {
        _ref = probes_and_matchers[_i], probe = _ref[0], matcher = _ref[1];
        result = ƒ["new"]._delete_grammar_references(G.use_statement.run(probe));
        _results.push(test.eq(result, matcher));
      }
      return _results;
    }
  };

}).call(this);

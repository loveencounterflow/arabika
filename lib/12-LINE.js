// Generated by CoffeeScript 1.7.1
(function() {
  var BNP, TRM, alert, badge, debug, echo, help, info, log, rpr, warn, whisper, ƒ;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '﴾12-line﴿';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  ƒ = require('flowmatic');

  BNP = require('coffeenode-bitsnpieces');

  this.options = {
    'line-parsers': [(require('./11-loop')).break_statement, (require('./11-loop')).loop_keyword, (require('./10-assignment')).assignment, (require('./6-route')).route]
  };

  this.constructor = function(G, $) {
    G.line = function() {

      /* TAINT we've built quite a contraption with these triple-nested `ƒ.or`s... */
      return ƒ.or(function() {
        var parser;
        return ƒ.or.apply(ƒ, (function() {
          var _i, _len, _ref, _results;
          _ref = $['line-parsers'];
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            parser = _ref[_i];
            _results.push(ƒ.or(function() {
              return parser;
            }));
          }
          return _results;
        })());
      }).describe('line');
    };
    G.tests['line: break'] = function(test) {
      var keyword, matcher, probe, probes_and_matchers, result, _i, _len, _ref, _results;
      keyword = 'break';
      probes_and_matchers = [
        [
          "" + keyword, {
            "type": "break-statement",
            "keyword": "break"
          }
        ]
      ];
      _results = [];
      for (_i = 0, _len = probes_and_matchers.length; _i < _len; _i++) {
        _ref = probes_and_matchers[_i], probe = _ref[0], matcher = _ref[1];
        debug;
        result = ƒ["new"]._delete_grammar_references(G.line.run(probe));
        debug(JSON.stringify(result));
        _results.push(test.eq(result, matcher));
      }
      return _results;
    };
    G.tests['line: loop'] = function(test) {
      var keyword, matcher, probe, probes_and_matchers, result, _i, _len, _ref, _results;
      keyword = 'loop';
      probes_and_matchers = [["" + keyword, "" + keyword]];
      _results = [];
      for (_i = 0, _len = probes_and_matchers.length; _i < _len; _i++) {
        _ref = probes_and_matchers[_i], probe = _ref[0], matcher = _ref[1];
        debug;
        result = ƒ["new"]._delete_grammar_references(G.line.run(probe));
        _results.push(test.eq(result, matcher));
      }
      return _results;
    };
    G.tests['line: assignment'] = function(test) {
      var keyword, matcher, probe, probes_and_matchers, result, _i, _len, _ref, _results;
      keyword = 'loop';
      probes_and_matchers = [
        [
          "x: 42", {
            "type": "assignment",
            "lhs": {
              "type": "relative-route",
              "raw": "x",
              "value": [
                {
                  "type": "Identifier",
                  "x-subtype": "identifier-without-sigil",
                  "name": "x"
                }
              ]
            },
            "mark": ":",
            "rhs": {
              "type": "NUMBER/integer",
              "raw": "42",
              "value": 42
            }
          }
        ]
      ];
      _results = [];
      for (_i = 0, _len = probes_and_matchers.length; _i < _len; _i++) {
        _ref = probes_and_matchers[_i], probe = _ref[0], matcher = _ref[1];
        result = ƒ["new"]._delete_grammar_references(G.line.run(probe));
        _results.push(test.eq(result, matcher));
      }
      return _results;
    };
    return G.tests['line: route'] = function(test) {
      var keyword, matcher, probe, probes_and_matchers, result, _i, _len, _ref, _results;
      keyword = 'loop';
      probes_and_matchers = [
        [
          "x/foo/bar", {
            "type": "relative-route",
            "raw": "x/foo/bar",
            "value": [
              {
                "type": "Identifier",
                "x-subtype": "identifier-without-sigil",
                "name": "x"
              }, {
                "type": "Identifier",
                "x-subtype": "identifier-without-sigil",
                "name": "foo"
              }, {
                "type": "Identifier",
                "x-subtype": "identifier-without-sigil",
                "name": "bar"
              }
            ]
          }
        ]
      ];
      _results = [];
      for (_i = 0, _len = probes_and_matchers.length; _i < _len; _i++) {
        _ref = probes_and_matchers[_i], probe = _ref[0], matcher = _ref[1];
        result = ƒ["new"]._delete_grammar_references(G.line.run(probe));
        _results.push(test.eq(result, matcher));
      }
      return _results;
    };
  };

  ƒ["new"].consolidate(this);

}).call(this);

// Generated by CoffeeScript 1.7.1
(function() {
  var BNP, TRM, alert, badge, debug, echo, help, info, log, rpr, warn, whisper, ƒ;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '﴾10-assignment﴿';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  ƒ = require('flowmatic');

  BNP = require('coffeenode-bitsnpieces');

  this.options = {
    'loop-keyword': 'loop',
    'break-keyword': 'break',
    INDENTATION: require('./7-indentation')
  };

  this.constructor = function(G, $) {
    G["break"] = function() {
      return ƒ.or(function() {
        return $['break-keyword'];
      }).onMatch(function(match, state) {
        return G.nodes["break"](state);
      }).describe('break');
    };
    G.loop_keyword = function() {
      return ƒ.or(function() {
        return $['loop-keyword'];
      }).onMatch(function(match, state) {
        return G.nodes.loop(state);
      });
    };
    G.loop_statement = function() {
      return ƒ.seq((function() {
        return $['loop-keyword'];
      }), function() {
        return $.INDENTATION.$['opener'];
      }, function() {
        return G.lines;
      }, function() {
        return $.INDENTATION.$['closer'];
      }).onMatch(function(match, state) {
        whisper(match);
        return match;
      }).describe('loop');
    };
    G.nodes["break"] = function(state) {
      return ƒ["new"]._XXX_YYY_node(G["break"].as, state, 'break', {
        'keyword': $['break-keyword']
      });
    };
    G.nodes.loop = function(state) {
      return ƒ["new"]._XXX_YYY_node(G.loop.as, state, 'loop', {
        'keyword': $['loop-keyword']
      });
    };
    G.tests['break: break keyword'] = function(test) {
      var keyword, matcher, probe, probes_and_matchers, result, _i, _len, _ref, _results;
      keyword = $['break-keyword'];
      probes_and_matchers = [
        [
          "" + keyword, {
            "type": "break",
            "keyword": "break"
          }
        ]
      ];
      _results = [];
      for (_i = 0, _len = probes_and_matchers.length; _i < _len; _i++) {
        _ref = probes_and_matchers[_i], probe = _ref[0], matcher = _ref[1];
        result = ƒ["new"]._delete_grammar_references(G["break"].run(probe));
        _results.push(test.eq(result, matcher));
      }
      return _results;
    };
    G.tests['loop: keyword and stage'] = function(test) {
      var keyword, matcher, probe, probes_and_matchers, result, _i, _len, _ref, _results;
      keyword = $['loop-keyword'];
      probes_and_matchers = [["" + keyword + "\n  foo\n  bar\n  baz", {}]];
      _results = [];
      for (_i = 0, _len = probes_and_matchers.length; _i < _len; _i++) {
        _ref = probes_and_matchers[_i], probe = _ref[0], matcher = _ref[1];
        probe = $.INDENTATION.$_as_bracketed(probe);
        whisper(probe);
        result = ƒ["new"]._delete_grammar_references(G.loop_statement.run(probe));
        _results.push(debug(JSON.stringify(result)));
      }
      return _results;
    };
    return G.tests['loop: refuses to parse dedent'] = function(test) {
      var keyword, matcher, probe, probes_and_matchers, result, _i, _len, _ref, _results;
      keyword = $['loop-keyword'];
      probes_and_matchers = [["" + keyword + "\n  foo\n  bar\n  baz\nbling", {}]];
      _results = [];
      for (_i = 0, _len = probes_and_matchers.length; _i < _len; _i++) {
        _ref = probes_and_matchers[_i], probe = _ref[0], matcher = _ref[1];
        result = ƒ["new"]._delete_grammar_references(G.loop_statement.run(probe));
        _results.push(debug(JSON.stringify(result)));
      }
      return _results;
    };
  };

  ƒ["new"].consolidate(this);

}).call(this);
